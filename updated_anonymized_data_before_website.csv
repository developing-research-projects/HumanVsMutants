user_id,mutant_id,time_taken,status,decision,explanation,created_at,updated_at,,maybe,no,yes,label_count,majority_decision,Maybe/No/Yes
63,1,5,SUBMITTED,yes,"The mutant is a bug because the sequence of input values sent to the hash() method to generate a hashcode, has been altered as compared to the original code. The resulting hashcodes for the mutant and the original code, for the same set of ""option"" and ""longOption"" values, therefore, shall be different.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
20,1,13,SUBMITTED,yes,Changing the order of the parameters passed to the hash function will change the hash code being generated,6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
76,1,12,SUBMITTED,yes,"Different hashcode will be produced by Objects.hash(option,LongOption) and Objects.hash(LongOption, option)",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
3,1,5,SUBMITTED,no,The order in which the parameters are passed for Objects.hash() doesn't matter so they behave the same. No bug,6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
1,4,2,SUBMITTED,yes,different behavior,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
15,4,4,SUBMITTED,yes,"In the mutant code, the if condition should have been if (hasArg == 0) so that the mutant to not be buggy as argCount was not initialised before checking if it is equal to 0",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
90,5,5,SUBMITTED,yes,"The change from setting OptionBuilder.required to true directly, to toggling its value with OptionBuilder.required = !OptionBuilder.required;, alters the functionality in a way that the subsequent call to isRequired() could inadvertently change a previously set requirement state. This could lead to logical errors where an option expected to be required could be marked as optional, or vice versa, depending on the number of times isRequired() is called, which is not the intended or expected behavior of setting an option as required.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
55,5,22,SUBMITTED,yes,"The mutant code toggles the required flag, different from the original code in which the required flag is always set to true. Thus, the mutant is a bug",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
1,6,2,SUBMITTED,yes,The offset becomes 1 and length becomes 0. This will throw an exception.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
88,6,5,SUBMITTED,yes,Second and third arguments to write function define the offset and the number of bytes to be sent. Mutant code always ignores the first byte(because the offset is 1) so it is buggy.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
8,7,6,SUBMITTED,yes,"The modification in the write(final int i) method increases the number of bytes written from 1 to 2, potentially introducing a bug since the intention was to write one byte. The discrepancy in the number of the byte written might impact the functionality.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
71,7,4,SUBMITTED,yes,trying to throw exception,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
93,12,7,SUBMITTED,yes,The mutant code is buggy because it does not handle the case when indexProducer is null.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
26,12,8,SUBMITTED,yes,"indexProducer is required to be non-null, while the if clause checks if it is null and executes the same statement.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
77,15,3,SUBMITTED,no,They have the same functionality.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
24,15,3,SUBMITTED,no,"as INDEX_NOT_FOUND is typically defined as -1, both codes provides same result",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
36,16,4,SUBMITTED,no,Mutant and original return same value. Mutant checks for null values.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
83,16,9,SUBMITTED,no,"Both codes have the same logic, but the original code has an extra check, which makes it return false if any of the objects are null. The code’s logic is to return true when both objects are true; which is achieved by both codes. If any of the objects are null, the anding of them will not return true. Anding of 2 objects will return true only when both objects are true.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
75,22,21,SUBMITTED,yes,"In the original method, the first predicate(condition) that evaluates to true executes its closure(statement), and the loop stops. This is a first-match-wins logic. But if we reverse the order of predicate checking, and if there are other predicates that return true, different closure gets executed. So, reverse traversing the conditions(predicates) may lead to unwanted behaviour changes.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
96,22,2,SUBMITTED,yes,The order is important,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
96,23,2,SUBMITTED,yes,The index might be out of range,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
3,23,5,SUBMITTED,yes,"The modified code will throw IndexOutOfBoundException because when set.size() = 7 it only has index till 6 and when i == 7, it will throw that exception.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
98,24,4,SUBMITTED,no,"The left and right side are semantically equivalent because the order in which side effects are caused does not matter as long as side effects are independent of each other, which in this case they are since each side effect is only reassinging the value of a variable and cannot be more nested.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
50,24,8,SUBMITTED,yes,The mutant is setting nextObjectSet to true before the actually setting the object which will affect the next loop,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
47,24,6,SUBMITTED,no,Changing the sequence of the two lines of code withing a single iteration will not have any change in the program behaviour as the lines of codes are not dependent.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
28,27,5,SUBMITTED,yes,- as  `this.lastItedex = --this.index;` This decrements the value of **`this.index`** and then assigns the decremented value to **`this.lastItedex`**.  `this.lastItedex = this.index--;`: This assigns the current value of **`this.index`** to **`this.lastItedex`** and then decrements the value of **`this.index`**.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
100,27,3,SUBMITTED,yes,"off by one, due to pre- and post-decrements. Can lead to bugs, for example, while using set()",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
61,29,4,SUBMITTED,no,setvalue has void datatype,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
29,29,2,SUBMITTED,yes,"Original code simply sets the value of the ""Map.Entry<K, V> entry"" to the passed object value and returns the passed object after it whilst the mutated code returns null and in that way introduces the undefined behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
88,29,5,SUBMITTED,yes,"The class is a decorator over Map Entry. So if the setValue dosen't change the decorated Map Entry object, the behavoiur would be buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
28,30,5,SUBMITTED,no,As decorated(); will just return the collection being decorated and cast it to List and will not change it,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
7,30,15,SUBMITTED,no,Both functions acts as a same way. The mutant is just checking if it is initialized and doesn't change the impact on the code.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
37,38,6,SUBMITTED,yes,"If the decorated current object (this) is null but not equal to the object passed in the argument, the correct code returns false but the mutated code returns true as soon as it sees decorated()== null. So this is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
69,38,4,SUBMITTED,yes,In the mutant code we would return true even if decorated() is null which is not the case in original code. Also in the original code we would return true if current object and comparision object point to the same memory adress which is not the case in mutant.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
40,42,4,SUBMITTED,no,"Mutated code produces the same output as of the original code.The mutated code creates a clone of the HashedMap by explicitly creating a new map and copying all elements from the original map. The original code uses super.clone(), both the code should produce a similar results. The mutated code is more explicit in this process but may have slight performance overhead.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
61,42,4,SUBMITTED,no,Clones the map without cloning the keys or values as in the first expression(original code),6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
41,43,7,SUBMITTED,no,"output is same for both however to the right, there's a check for the key parameter if it's empty or not and it's value is passed to the getEntry method and that is then assigned to the Entry variable.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
71,43,4,SUBMITTED,no,it seems like is not a bug but the code was missing intentionally.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
90,43,5,SUBMITTED,no,"The edited code introduces a check for null keys before calling getEntry, potentially improving efficiency or clarity but does not alter the method's behavior. Both versions return false for null or not found keys, so this change does not introduce a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
72,46,5,SUBMITTED,no,"The order is mutated, not the conditions themselves. Since both conditions have to be met, the order of testing them does not matter.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
25,46,2,SUBMITTED,no,"Only the order of the conditional statements were changed in the mutated code from the original code, therefore, the behavior remains the same",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
15,51,4,SUBMITTED,yes,The original code is used to access the decorated MultiSet object. The mutant code doesn't do that and always returns null,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
97,51,2,SUBMITTED,yes,This is because decorated method doese not always return null,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
45,54,30,SUBMITTED,yes,"The original code method returns true if keyAnalizer is a bit set. In the mutant code, the method returns true if keyAnalizer is not a bit set, and therefore, it is a buggy mutant.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
51,54,15,SUBMITTED,yes,as the mutant is the complementary (not ) of whatever the left returns.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
61,54,4,SUBMITTED,yes,Results of a and !a are always opposite,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
15,54,4,SUBMITTED,yes,The mutant will output the opposite of what the original code was supposed to output,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
25,58,2,SUBMITTED,no,"In both the original and mutated code, the variable item is getting converted into an arraylist, therefore, they will exhibit the same behavior",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
41,58,7,SUBMITTED,no,"the was more conversion to the right of items to get the hashSet whilst to the right it was created directly. overall, the output remains same.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
67,72,15,SUBMITTED,yes,"Since return value of getOrder function is used in this expression exp = -1.0 / getOrder();"" in file ""EmbeddedRungeKuttaIntegrator.java"", I think it makes this mutant code, buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
97,72,2,SUBMITTED,yes,the mutant will return 799 because 800-1 is returned. Since DYNAMIC_POINTER_FACTORY_ORDER is final it cn be changed. the code does not change it,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
13,80,9,SUBMITTED,yes,"The mutant checks if the parent is null and appends a '/' to the end of the buffer if it is, while the orignal code does not do anything if the parent is null. This will not result in a bug but will result in different results from the original.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
92,80,21,SUBMITTED,yes,"It fails to correctly handle the case when the parent node is null. Instead of appending a slash directly to the buffer, it should continue to evaluate whether appending a slash is necessary, which might lead to generating incorrect paths, especially when the path should start from the root node rather than directly from the node's name.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
52,82,36,SUBMITTED,yes,"return true means that the code will always run true, and this is not correct, super.isDefaultFullDetail() relies on the behavior defined in the superclass ToStringStyle to detere whether to use full detail.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
85,82,2,SUBMITTED,yes,unconditionally returns true,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
26,83,8,SUBMITTED,yes,"shiftCount is zero if mask is zero, not one.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
6,83,11,SUBMITTED,yes,The change in the condition from mask == 0 to mask == 1 alters the logic for initializing shiftCount,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
1,87,2,SUBMITTED,yes,There would be some true cases.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
56,87,4,SUBMITTED,yes,"The method always returns false. It it is expected that it should return false aways then its not a bug, but then there is no need to write a function just to return false value.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
51,87,15,SUBMITTED,yes,"the mutant always returns a flat false whenever the function is called, but in the correct version it implements or reuses the methods usecase in the abstract superClass which returns fieldSeparatorAtEnd boolean variable. Which is declared but not instantiated with a value. So it might be true or false.And we can’t know for sure .",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
43,89,4,SUBMITTED,yes,The mutated code returns '-1' which is different from the return value of the original code.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
58,89,9,SUBMITTED,yes,"The mutant code is buggy because after evaluating some code below, the createExecutor() relies on getTaskCount() to detere the number of threads for the thread pool. If the getTaskCount() returns 0, it would result in newFixedThreadPool with zero threads, which is not valid and will throw an IllegalArgumentException because a thread pool cannot have zero threads.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
68,91,18,SUBMITTED,no,just changed the lambda expression to if else,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
47,91,6,SUBMITTED,no,In both scenarios the logical flow is same,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
45,91,30,SUBMITTED,no,The mutant code demonstrates a conditional operator way of the ternary operator implementation. The output of both the original code and the mutant code are the same.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
20,93,13,SUBMITTED,yes,The value of openingThreshhold being returned is different. In the mutant code the value returned -1.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
53,93,13,SUBMITTED,yes,"The correct opening threshold is not being returned, instead we are returning the openingThreshold - 1",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
87,93,9,SUBMITTED,yes,because the output of the buggy code will always be one less than than the input,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
94,95,30,SUBMITTED,no,The original code and mutant code are functionally identical. The difference in error message doesn't affect the implementation of the overall code.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
33,95,4,SUBMITTED,yes,"It is buggy because it changes the behavior of the code in terms of order of parameter check and it also returns resource with name resourceName must not be null, instead of resourceName, as the original version would return.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
16,95,7,SUBMITTED,no,"The change introduced in the mutated version provides a more specific error message when resourceName is null, stating explicitly that it must not be null. This change is an improvement in terms of clarity and precision of the error message.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
18,102,3,SUBMITTED,no,"Since last is set to be equal to value, both original and mutated versions increments value by 1.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
73,102,4,SUBMITTED,no,"Since variable 'last' equals 'value' , the value of parameter 'value' will be same in both original and mutate code snippet.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
48,104,10,SUBMITTED,no,"The original code returns the new value of 'value', that is 'value -1' while the mutant code directly returns 'value - 1' therefore the mutant is not buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
36,104,4,SUBMITTED,no,Both return the same value. Normal code decrements using 'value--' which decrements the value and then returns it. The mutant uses '--value' which returns the decremented value.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
66,107,14,SUBMITTED,yes,yes mutant is buggy because getAndAddmethod by multiplying value with operand instead of just using value. it changes the behaviour or result,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
95,107,68,SUBMITTED,no,Similar to original,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
104,107,5,SUBMITTED,yes,mutant changes the return value,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
11,110,2,SUBMITTED,no,The last variable will be assigned value + 1 and we can return the last - 1. what we cant do is to decrement the variable last because it is declared final.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
2,110,6,SUBMITTED,no,+1 and -1 does not affect the final value unless there is an overflow,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
106,110,2,SUBMITTED,no,"both codes return the same thing, the only difference is the mutant adds 1 more the the last value but takes it out at the end, so it ends up resulting the the same thing as the original code",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
71,113,4,SUBMITTED,no,"IntStream.range(x,y) would return a stream from x(inclusive) and y(exclusive). IntStream.rangeClosed(x,y) would return a stream from x(inclusive) and y(inclusive).",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
21,113,6,SUBMITTED,no,"In the Intstream.rangeClosed(), you are considering the upper bound, in the Intstream.range() you are not. Thus when you call Intsream.rangeClosed(a, b) is the same as Intstream.range(a, b+1)",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
33,113,4,SUBMITTED,yes,The addition of 1 to the endInclusive Parameter.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
100,115,3,SUBMITTED,yes,The new statement leads to a zero-division error and the method call will always fail (unexpectedly).,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
35,115,6,SUBMITTED,yes,"Dividing a number by 0, raises an error.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
17,120,30,SUBMITTED,no,Mutant expression is equivalent,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
91,120,7,SUBMITTED,yes,Even though the hashcode of each of the objects are the same it does not necessarily mean that the objects are equal. This shows that the two functions have different behaviors.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
50,120,8,SUBMITTED,yes,The original code uses Object.equals to check equality which also handle null values. The mutant is comparing hashcodes which doesn't cover for null values,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
39,127,3,SUBMITTED,yes,"The original block of code defines a static final EMPTY_ARRAY array initialized with an empty array {}. Then, it returns it casted to the generic type <L, R>. This will create a shared empty array instance that can be shared across code.  The mudtated block of code creates a new empty array arr of type Pair<L, R>[] with a length of 0, and then returns it. This creates a new empty array every time the method is called.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
45,127,30,SUBMITTED,no,This mutant utilizes another way to implement an empty array.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
50,127,8,SUBMITTED,no,Both the original and mutant code return an empty array of Pair objects,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
50,134,8,SUBMITTED,no,Both the original and mutant code remove the bit at bitIndex,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
104,134,5,SUBMITTED,no,clear and set false do the same thing in this case,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
23,137,4,SUBMITTED,yes,"Because in actual version the randint would be [0, MAXINT) but in mutant code we can never get the value 0 as randint due to the range [1, MAXINT). In addition the docstrings says random int from 0 - MaxValue but its output is 1 - MaxValue",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
76,137,12,SUBMITTED,no,"It only generates random number from 1 to MAX_VALUE, while the original code generates from 0 to MAX_VALUE.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
98,137,4,SUBMITTED,yes,The left side has the potential to generate a random number with smallest value 0 but the right side can only take a smallest value of 1.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
66,139,14,SUBMITTED,maybe,"mutation may be buggy but in Double._VALUE, which is the smallest positive nonzero value small positive value close to zero. in coorect code we have range of output from smallest positive nummber greater than zero and Double.MAX_VALUE while in mutated code we have range of 0 to Double.MAX_VALUE  so there is slight change in output it depends it can be bug or may not be because Double._VALUE is very very small positive value close to zero.",6/26/2024 3:46,6/26/2024 3:46,0,2,0,0,2,maybe,2/0/0
82,139,2,SUBMITTED,maybe,"Instead of using 0, the mutant code uses the  value a double can hold.",6/26/2024 3:46,6/26/2024 3:46,0,2,0,0,2,maybe,2/0/0
66,146,14,SUBMITTED,no,both give same result so mutant has no bug as directly calls System.getProperty(JAVA_LIBRARY_PATH) to retrieve the Java library path. but in mutated code AVA_LIBRARY_PATH using System.getProperty() both recieves Java library path in the same way so there is no change in result,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
75,146,21,SUBMITTED,yes,"Original code (Apache Commons Lang version) has a try-catch block for handling SecurityException, which might be thrown if the security manager prevents access to the property. If such an exception occurs, it quietly defaults to the supplied default value without throwing an error. But in the mutant version (which uses Java's System library), if access to the property is not allowed, a SecurityException is thrown. That exception may crash the program while running.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
87,146,9,SUBMITTED,no,"Both codes will, have the same output and behavior because the change of will not affect the output",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
14,148,4,SUBMITTED,yes,"""line_separator"" returned isnted of getProperty(""line.separator"") is buggy version",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
11,148,2,SUBMITTED,yes,The mutated code return the string “LINE_SEPARATOR” while the original return the “\r\n” or “\n”.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
91,149,7,SUBMITTED,no,"the original function would have returned null if the input property was null, making the mutant code to have same behavior. However, the mutant code is redundant.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
62,149,6,SUBMITTED,no,"The mutant eliates the redundant null check, allowing for proper handling of null inputs by getProperty(property, NULL_SUPPLIER).",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
39,150,3,SUBMITTED,no,"According to the implementation of getProperty, if an exception raised, so it will return the SystemUtils property value will default which is null, so it is unnecessarily to return another null.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
26,150,8,SUBMITTED,yes,"All exceptions are caught erroneously, while only SecurityException instances must be caught.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
85,150,2,SUBMITTED,yes,unnecessarily catches all exceptions,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
78,153,9,SUBMITTED,yes,The mutant code is always taking null and will provide same return value. But the original code return value relies on numberofpoints and hermite,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
37,153,6,SUBMITTED,yes,The correct version of the code returns an object of type SymmetricGaussIntegrator constructed with the return value of the getRule function(with hermite as one of its arguments). Passing null to the constructor and creating the object with create it with different specifications and hence it is a bug.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
49,168,10,SUBMITTED,yes,"The constructor is calling another constructor with the argument true. In the mutant code, it's calling the same constructor with the argument null.  A Boolean in java, can be null . If a boolean is not assigned a value (say a member of a class) then it will be false by default. Thus the two codes are not equivalent.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
62,168,6,SUBMITTED,yes,"Constructors expect valid arguments. Passing null to a boolean constructor is likely a bug, as it can cause NullPointerExceptions or unexpected object initialization.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
79,168,2,SUBMITTED,yes,"In the original code, this(true) is used which eventually calls constructor StorelessBivariateCovariance(final boolean biasCorrection) setting the value of biasCorrected to true. But in the mutant version, this(null) is called which will pass ""null"" as the boolean parameter biasCorrection in the constructor. In this case, it will fail to convert null into a true/false boolean value resulting in an compilation error.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
101,168,6,SUBMITTED,yes,"Yes. this() is used to call on a constructor. We see that in the mutant case, the attribute biasCorrected is said to be null instead of true like in the original version. Later on in the function getResult(), this difference will lead to a different output as caught in the if branches.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
19,176,2,SUBMITTED,yes,"Instead of updating the bias corrected value to the one specified by the function, it changes it to false when function is passed the value true and does nothing otherwise resulting in buggy behavior",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
54,176,6,SUBMITTED,yes,"The original code states that the member variable ""biasCorrected"" will always take the bool value of the local ""biasCorrected"". However, in the mutant code, it negates this value (if true, then false). In addition, if the condition isn't met, it doesnt update the member variable. So the mutant code is buggy as it changes the behaviour of the original",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
8,176,6,SUBMITTED,yes,"In the original code, the this.biasCorrected is initialized to the value of biasCorrected parameter. Whereas in mutant code, the this.biasCorrected is set to false when the biasCorrected paramater is true and vice-versa. This change inverted the logic of initializing the this.biasCorrected and change the outcome and behavior of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
57,176,5,SUBMITTED,yes,"The constructor in the mutant sets this.biasCorrected = false if input argument biasCorrected is true, instead of setting this.biasCorrected = biasCorrected.  The mutant behaves differently when the biasCorrected is true.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
38,179,1,SUBMITTED,yes,In the mutant code there the increment of the variable i in the loop is repeated twice. This would mean skiping entire indices. This is a bug,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
60,179,8,SUBMITTED,yes,Incrementing the counter within the for loop will leading to it being incremented twice and therefore the retrieval of the wrong values.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
63,179,5,SUBMITTED,yes,"In the mutant, the loop counter is incremented by one just like in the original code. However, within each iteration, the its value is incremented again due to ""i++"" as part of the array indexing (means[i++]). Every alternate element is skipped in the ""means"" array and there is a possibility that the array access goes out of bounds. Therefore, the given mutant is a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
34,188,3,SUBMITTED,no,Assug that we are not relying on eol for the initialization of the indents array.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
15,188,4,SUBMITTED,no,"No difference as eol was not altered or even used in the rest of the function, so there is no difference where this.eol = eol is",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
32,188,20,SUBMITTED,no,"In the original case, the statement ""this.eol = eol"" is on line 65. But in the mutated case, the statement ""this.eol = eol"" is on line 57.  This change does not alters the expected behaviour of the code. And given eol was already defined and it is not used in any other place in the function, doing this does not cause a bug",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
73,190,4,SUBMITTED,yes,"In the original code , if feature is enabled i.e.  _enabled is set to 1 , it will return True but if set to 0 it will return False.  However, in the mutated code if feature is enabled (1) because of ~ (unary complement operator) the function will return False",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
27,190,3,SUBMITTED,yes,"The mutant code is buggy because it uses a negation in a way that likely inverts the intended check for whether a feature is enabled. Instead of confirg if a feature is enabled, it mistakenly checks if it's not, leading to incorrect results. The correct operation should check if the bits are set in both “feature.getMask()” and “_enabled”, suggesting this code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
22,193,4,SUBMITTED,yes,Changing in the length of the array being written will cause an ArrayIndexOutOfBoundsException when attempting to access the invalid position added extra.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
97,193,2,SUBMITTED,yes,It will make it throw an out of bounds exeption.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
21,196,6,SUBMITTED,yes,"In the main code, the bits disabling is happening as follows: bitwise complement, bitwise and. The mutated code does the following: subtract 1, bitwise and. These two different approaches yield into 2 different results.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
102,196,10,SUBMITTED,yes,"The mutated code does not give the same deterministic output as the original code. The reason is that the original code uses a bitwise NOT to invert the bits of the mask before performing the AND operation, effectively clearing specific bits in _streamReadFeatures. The mutated code subtracts 1 from the mask instead, which can alter a different set of bits in _streamReadFeatures. This change can lead to different outcomes depending on the specific bit patterns involved.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
104,196,5,SUBMITTED,yes,mutant code no longer takes compliment and subtracted 1 from the final,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
6,199,11,SUBMITTED,yes,The mutated code is not returning the same thing as the correct code,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
94,199,30,SUBMITTED,no,"The return statement of the 'requireCtorAnnotation()' method is just a fixed version of the one in the original code, and would function exactly the same way as the correct code if '_requireCtorAnnotation' were to return 'false'. It doesn't affect the overall implementation of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
59,199,2,SUBMITTED,yes,correct code can return true but mutant code will always return false,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
35,201,6,SUBMITTED,yes,The code execution behavior will change.,6/26/2024 3:46,6/26/2024 3:46,0,1,0,3,4,yes,1/0/3
16,201,7,SUBMITTED,yes,"Mutated version has ""false""  in third parameter but original code has ""true""",6/26/2024 3:46,6/26/2024 3:46,0,1,0,3,4,yes,1/0/3
4,201,1,SUBMITTED,yes,"The last parameter passed to the function in the first code is false, while it's true in the second code.",6/26/2024 3:46,6/26/2024 3:46,0,1,0,3,4,yes,1/0/3
1,201,2,SUBMITTED,maybe,"boolean _allowJDKTypeCtors will always be false in mutant. This disables the auto-detection of constructors of ""JDK types."" I don't know if this is going to cause any issues or not",6/26/2024 3:46,6/26/2024 3:46,0,1,0,3,4,yes,1/0/3
2,207,6,SUBMITTED,yes,"A null provider may not be equal to 'deser', and in some cases, it may be omitted.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
9,207,9,SUBMITTED,yes,Buggy line Code maybe will not run,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
49,207,10,SUBMITTED,yes,In the original code the value of NullValueProvider nvp can be deser or _nullProvider on the basis of this condition (_valueDeserializer == _nullProvider). However in the mutant it is always automatically assigned to deser.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
102,208,10,SUBMITTED,yes,"The mutated code does not give the same deterministic output as the original code. The reason is that the original code conditionally sets the nvp based on the relationship between _valueDeserializer and _nullProvider, while the mutated code sets nvp to _nullProvider unconditionally. This change violates the intended behavior described in the comment and can lead to incorrect or inconsistent state in the program.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
99,208,6,SUBMITTED,yes,"The mutated version introduces a bug because it disregards the synchronization between _valueDeserializer and _nullProvider. The original code ensures that if _valueDeserializer is the same as _nullProvider, both are updated to maintain consistency. The mutated code fails to do this, leading to potential inconsistencies.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
2,209,6,SUBMITTED,yes,"When _valueDeserializer == null, the erroneous code returns 1, but it should actually return 0.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
34,209,3,SUBMITTED,yes,"The modified code introduces a bug. It changes the logical condition in the code. This change would always return true, regardless of the value of _valueDeserializer, as the second part of the condition will always evaluate to true when _valueDeserializer is not MISSING_VALUE_DESERIALIZER.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
40,209,4,SUBMITTED,yes,"The mutated code will produce different output than the original code. In the original code, the method returns true only if _valueDeserializer is not null and is not equal to a specific value (MISSING_VALUE_DESERIALIZER). In mutated code, the condition is changed, now the method will now return true if _valueDeserializer is either null or not equal to the specific value. This change can lead to the method returning true in cases where the original code would return false.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
94,209,30,SUBMITTED,yes,The 'public boolean hasValueDeserializer()' will return a false result of 'true' if '_valueDeserializer == null' returns true.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
22,211,4,SUBMITTED,yes,"_valueDeserializer.getNullValue() != null always evaluates to false, so the new if condition equivalent to throwing a JsonMappingException isusingIdentityInfo ^ _type.isPrimitive(). If the type is primitive, then usingIdentityInfo XOR 1 is NOT usingIdentityInfo, which is the same as the previous behavior. However, if the type is not a primitive, then usingIdentityInfo XOR 0 is usingIdentityInfo, which is different from the original behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
14,211,4,SUBMITTED,yes,"Correct code throws exception if `usingIdentityInfo` is false, but buggy code may throw exception when `usingIdentityInfo` is true",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
70,214,9,SUBMITTED,no,"Since both versions essentially call asInt(0) and return its result in different ways, they will produce the same output.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
102,214,10,SUBMITTED,no,The mutated code gives the same deterministic output as the original code. The reason is that both versions execute the same method call and return the same result. The introduction of the local variable result in the mutated code does not change the output of the method.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
42,219,15,SUBMITTED,no,it is even better than the correct one because it checks if index is negative value or not,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
67,219,15,SUBMITTED,no,I think it doesn’t create a problem to check whether index is smaller than 0. Because get() function already handles it.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
47,225,6,SUBMITTED,no,As in java objects are always passed by value,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
79,225,2,SUBMITTED,no,"Here, _name is a variable of String type. In the original case, _name is return directly. But in the mutant case, it is assigned to a temporary variable newName first, then returned. So, there is no change in behaviour for the mutant code. Therefore, it is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
88,226,5,SUBMITTED,yes,"If _value is a instance of Long (subclass of number), then in original code the defaultValue will not be used, but in mutant version the defaultValue will be used.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
79,226,2,SUBMITTED,yes,"Here, the reason is similar to No. 7.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
46,229,2,SUBMITTED,no,"The Integer class is a subset of number class. So if the value is an instance of integer class it is automatically an instance of Number class. In the original code, the number type (float, integer, byte short) is type casted to long integer type, where the decimal part if present is truncated. In the mutant code, the integer value is type casted to long integer type. No difference in outputs is seen between the two codes. Hence the mutant code is not buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
20,229,13,SUBMITTED,yes,"In the mutant code getClass().equals test whether the types are identical as well as casting _value to Integer if they are the same type, but instanceof checks for a type hierarchy Double or its subclasses and cast _value to Number which will result in different output depending on the object type in each case.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
5,229,18,SUBMITTED,yes,"The mutant code has changed the behavior of the asLong method. In the original code, if _value is an instance of Number, it directly casts _value to Number and returns its long value. If _value is not a Number, it returns the defaultValue.  In the mutant code, it checks if _value is an instance of Integer. If _value is an Integer, it casts _value to Integer and returns its long value. If _value is not an Integer, it returns the defaultValue.  This change in behavior could lead to bugs, as the method now only works correctly for Integer values. For other types of Number (like Double, Float, Long, etc.), the method will return the defaultValue instead of the long value of _value.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
68,229,18,SUBMITTED,yes,there must be a null check on _value it may throw exception,6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
102,238,10,SUBMITTED,no,"The mutated code gives the same deterministic output as the original code. The reason is that the logical OR operation with false does not change the value of defaultState. Therefore, the assignment _defaultState = defaultState || false; is functionally equivalent to _defaultState = defaultState;, leading to the same output in both cases.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
1,238,2,SUBMITTED,no,|| with false always return the same value,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
34,239,3,SUBMITTED,yes,"The modified code will return true when the text values are not equal, which is incorrect behavior for an equals method. Therefore, it does not correctly identify when two objects are equal and thus introduces a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
80,239,2,SUBMITTED,yes,"The original code checks if the “text” attribute of the object passed to the “equals” function matches with its own “text” attribute and return false when no match found. But the mutant version returns a true in this exact case of checking. Clearly, the mutant version produces a different output when invoked with this function concerned.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
99,239,6,SUBMITTED,yes,"The order of comparisons is slightly different, but the significant change is that if this.text is not equal to t.text, the method returns true instead of false.hence, leading to change of behaviour of program.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
103,240,6,SUBMITTED,yes,"The mutant is buggy because when the obj is null the left side would return true since all the bodies for the if statements would be false and then reach the end and return true, while the right side accounts for a null object and then returns false.",6/26/2024 3:46,6/26/2024 3:46,0,1,2,1,4,no,1/2/2001
74,240,2,SUBMITTED,no,Changes will not effect the code behaviour,6/26/2024 3:46,6/26/2024 3:46,0,1,2,1,4,no,1/2/2001
72,240,5,SUBMITTED,no,"An object of class XYItemEntity cannot be initialized to null. So any equality check with null fails anyway. The instance will still meet the conditions of the second if block, and the mutant will then return true.",6/26/2024 3:46,6/26/2024 3:46,0,1,2,1,4,no,1/2/2001
16,240,7,SUBMITTED,maybe,"The equals method begins with a null check, which is not inherently incorrect. However, depending on the intended behavior of the class, null may or may not be considered equal to instances of XYItemEntity",6/26/2024 3:46,6/26/2024 3:46,0,1,2,1,4,no,1/2/2001
44,241,45,SUBMITTED,yes,"The mutant code is indeed buggy. The bug is introduced when the AbstractCategoryItemLabelGenerator object that is assigned a null value. This will cause a NullPointerException when the labelFormat of this and that are compared in the following line: if (!this.labelFormat.equals(that.labelFormat)). In the original code, that is assigned the value of obj cast to AbstractCategoryItemLabelGenerator, which ensures that that is not null when its labelFormat is accessed. However, in the mutant code, that is explicitly set to null, which leads to a NullPointerException when its labelFormat is accessed. This change in the mutant code alters the behavior of the equals method, making it buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
6,241,11,SUBMITTED,yes,"I guessed on this one, I am not sure of the answer",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
53,242,13,SUBMITTED,yes,"Using the string ""INVALID_TEMPLATE"" generates a different instance than if the DEFAULT_TEMPLATE was used",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
61,242,4,SUBMITTED,yes,"DEFAULT_TEMPLATE = ""%2$s to %3$s = %4$,.2f""; The given string has different output then ""INVALID_DEFAULT""",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
103,242,6,SUBMITTED,yes,The mutant is buggy because you are calling a constructor and then creating an instance for a default template while on the right you are calling a constructor and creating an instance for an “Invalid Template” which is different from the DEFAULT_TEMPLATE,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
93,243,7,SUBMITTED,yes,"if object is null, equals method in correct code returns false while mutant code returns true.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
34,243,3,SUBMITTED,yes,"The modified code is changing the logic of  the code by changing the conditional statements , also by returning true when the object is null.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
92,246,21,SUBMITTED,yes,"In the mutated code, the `getOrder` method returns half of the length of the `coefficients` array. This is clearly incorrect because it is not the correct method to calculate the order of a polynomial. If this mutation were introduced into the code, it would result in the `getOrder` method returning incorrect results, potentially affecting any calculations or decision logic relying on the order of the polynomial.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
17,246,30,SUBMITTED,yes,The response of the function would change,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
78,247,9,SUBMITTED,yes,"Because of the obj == null condition in mutant, in case of null object it may return different results for the original and mutant code",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
17,247,30,SUBMITTED,yes,Null is not equivalent to an object,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
69,249,4,SUBMITTED,yes,In mutant code there is double to int conversion so values greater than max value of int would have different results,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
76,249,12,SUBMITTED,yes,"The function setIntervalPositionFactor expects a double value, while the mutated version typecasts to int before passing.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
97,249,2,SUBMITTED,no,there are no bugs because java can by default cast an int as an double. This is because the Double is higher than an int in the number hierarchy,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
89,254,19,SUBMITTED,yes,The output of the code changes. The left code snippet will throw an error about the 'type' whenever the 'type' will be null whereas the right code snippet will throw error mentioning 'duration type' without accounting for the 'type' (not even when it is null).,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
83,254,9,SUBMITTED,yes,"The original code is supposed to throw the exception when there is a null duration. The buggy code has a logical error. It checks if “type” is not null, which contradicts the purpose of the check and throws the wrong exception as well as it says “The DateTimeFieldType must be null” which also emphasizes the incorrect logic. The code also may result in NullPointers when using “DateTimeField field = type.getField(getChronology());”  since the exception is not correctly thrown, if it is null, the code will get to this line and will execute it, which will result in NullPointerException. So, the code is not safe to execute.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
29,255,2,SUBMITTED,yes,It seems to me that joda-time supports negative time intervals. Mutated code maps any given negative amount of seconds to zero hours which is not intended.,6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
32,255,20,SUBMITTED,maybe,"In some cases, the original case and the mutant case will have the same output But when the integer variable value is less than 0 in the mutant case, the output will be different from that of the original case",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
43,255,4,SUBMITTED,yes,"The mutated code and the original code operate identically only when getvalue() returns a negative value, which is unacceptable.",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
64,256,8,SUBMITTED,no,"The mutated code replaces DateTimeConstants.DAYS_PER_WEEK with constant value 7, it does not create a bug since the semantic and behavior of the function remain same",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
78,256,9,SUBMITTED,no,It is not buggy because the constant value equals to 7. and it wont affect the behavior or result of the codes.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
59,257,2,SUBMITTED,no,both return same value for same years value,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
31,257,15,SUBMITTED,no,"The original and mutant codes are equivalent. Reversing if (years == 0) to if (years != 0) and swapping the two statements results in the same behavior. Therefore, the code’s output and behavior didn’t change.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
10,257,8,SUBMITTED,no,"The parameter 'years' can be 0, negative, or positive. In case it's 0, both the original and mutant code return the object that called the function, i.e. 'this'. For all other cases, both the original and mutant code execute the same function. Hence, the mutant would return the same value or raise exceptions as the original code for the same input.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
12,258,3,SUBMITTED,no,true && condition equals just checking for condition,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
53,258,13,SUBMITTED,no,"The result of True AND a boolean variable is the boolean variable (True AND A = A), and isBefore(DateTimeUtils.currentTimeMillis()) returns a boolean, hence True AND isBefore(DateTimeUtils.currentTimeMillis()) will give the same result as just calling isBefore(DateTimeUtils.currentTimeMillis())",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
54,259,6,SUBMITTED,no,"Both codes will have the same functionality, behaviour, and outcome.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
35,259,6,SUBMITTED,no,"Mutated and Original code returns a boolean value, and behavior of the code doesn't change.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
43,260,4,SUBMITTED,yes,"The return values of the mutated code and the original code are opposite, which may cause a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
44,260,45,SUBMITTED,yes,"The mutant code is indeed buggy. In the original code, the containsNow method checks if the current time is contained within a certain range (defined by the contains method) and returns true if it is. This is done in an infinite loop, which means the method will not return until the current time is within the range.  In the mutant code, the containsNow method returns the negation of the contains method for the current time. This means it will return true if the current time is not within the range and false if it is. This is a significant change in behavior from the original code, making the mutant code buggy. Furthermore, the mutant code does not have an infinite loop, so it will return immediately, regardless of whether the current time is within the range or not. This is another significant change in behavior from the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
93,261,7,SUBMITTED,no,getimumValue method in both code snippets return 1. The intermediate computation in mutant code does not have any side effects.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
70,261,9,SUBMITTED,no,"The mutant code calculates result from a and b but the variable ‘result’ is not returned by the function or used by any other piece of code in the give file. Hence, output would not differ.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
52,265,36,SUBMITTED,no,"The change to the method set is only to prevent any invalid inputs by checking if the value returns -1 and throwing an IllegalArgumentException, so the addition of these lines to the method prevents the invalid text from causing further issues in the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
60,265,8,SUBMITTED,no,"Unnecessary check as the iParseEras map is only being filled with positive values so it won't return any negative values, but this, regardless, will not hinder the desired functionality.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
7,274,15,SUBMITTED,yes,The mutant is defined to return null in certain conditions which will result in bug.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
52,274,36,SUBMITTED,yes,"I think the comment in the code means that there is an intention to make a test for that bug and it is already known that this is buggy code, because the attempt to return null in a method that is supposed to return a primitive int will result in a compilation error. To summarize null cannot be converted to an int in Java, this will cause an error",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
13,278,9,SUBMITTED,no,"They are not the same, because if value of the ""value"" variable is one less than the value of divisor, then it would pass the if statement, then go into the verifyinbound function with the value and it would check if the value is between 0 and idivisor-2, which would throw an exception because idvisior is only one greater than value. For example if value is 2 and idivisor is 3, it would not enter the if statement and go to the verifyincounds function. In the original code the check would be if 2 is in between 0 and 2, which would not throw an exception. In the mutant code the check would be if the value 2 is in between 0 and 1 which would throw an exception.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
70,278,9,SUBMITTED,no,"FieldUtils.verifyValueBounds checks if value is within the inclusive range [0, iDivisor - 1]. This means that even if value equals iDivisor - 2, it is considered valid and no change in output will be observed.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
78,278,9,SUBMITTED,yes,"The mutant included extra condition to change ""value"" so it might cause different result in different cases",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
60,281,8,SUBMITTED,no,"Given the original code works, we can assume that the value of iZone won't be null, so an additional null check should not hinder functionality.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
91,281,7,SUBMITTED,no,"You cannot use a member function on a object when it is null. The addition to the original code will not change the output and it redundant, but it is not buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
40,285,4,SUBMITTED,no,"Mutated code produces the same output as the original code. The difference is addition of new variable which is extracting the values from the same function getValue(). Addition of variable is not needed as it will unnecessarily occupy the memory, but improves readability of code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
38,285,1,SUBMITTED,no,"The new mutant code just replaces the getvalue function by a variable , this makes the code easy to read and implement. This is not a bug",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
29,286,2,SUBMITTED,yes,"The function ""usDays(int days)"" accept parameter ""days"". We can infer (from javadoc) that this variable represents the amount of days to be subtracted from the ""DateTime"" object this method is called on. We can also read that this value can be negative. If the value of variable ""days"" is negative function should return ""DateTime"" with the increased amount of days (because of the double negation). Mutated code returns null for all negative numbers, hence mutated code contains bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
46,286,2,SUBMITTED,yes,"In the original code, if days is 0 then the object instance 'this' is returned. In the mutant code, an entirely different condition 'days<=-1' is checked and null is returned if true. The two codes check different conditions and return different values. The mutant code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
52,287,36,SUBMITTED,no,"In my opinion I think this will not be considered as a buggy code, because this will not change the output or the behavior of the code they are declared but according to the whole code they were not used, they are additional lines which may only cause confusion but they are not considered as a buggy code.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
23,287,4,SUBMITTED,no,"Inserting extra day, month and year variable does affect the behavior or ouput of this method. Therefore it doesn't produce any bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
22,287,4,SUBMITTED,no,There is no change in functionality because we are creating 3 local variables which are simply deleted when we exit the constructor scope; the invocations are also completely valid.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
30,290,10,SUBMITTED,yes,"The mutated code sets the PubSysKey to “null” no matter what d.getPubSysKey() returns, which will result in a difference in the output or behavior of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
64,290,8,SUBMITTED,yes,It is a bug since we are ignoring the value of  d.getPubSysKey() and replacing it with null,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
105,290,0,SUBMITTED,yes,"The mutant changes the behavior of the method by setting the PubSysKey to null instead of using the value from the Token.Doctype. This is a clear behavioral change that can lead to incorrect handling of Doctype tokens, making it a bug. (Note that if d.getPubSysKey() return value is null, it is not buggy)",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
89,291,19,SUBMITTED,yes,"According to the toString() method of EOF class in another part of the code, EOF type converted to string will be an empty string: """". Other types including Doctype, StartTag, EndTag, and Comment can never be an empty string when converted to string. However, Character type is an exception. According to the code, the Character class has an String attribute 'data'. There is a possibility that this could be empty (although there are no empty characters in Java). If 'type' on line 490 is 'Character' and the 'data' is empty, type.toString() will return an empty string. This will make the output of the function true when it should be false because Character is not equal to EOF.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
105,291,0,SUBMITTED,no,"In Java, TokenType.EOF.toString() and TokenType.EOF have the same effect because TokenType.EOF inherently uses toString() to return its string representation. Thus, the mutant's behavior is the same as the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
30,291,10,SUBMITTED,no,"In the mutated code, the comparison is between the string representations of enum constants. This comparison will not introduce a bug as it does not change the output and behavior of the code because any representation of an Enum is pointing to the same object instance.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
101,296,6,SUBMITTED,yes,"Yes. In the case where data is equivalent to null, the original code passes it into isXmlDeclaration() which will throw an error as you cannot invoke the function length() on null. The mutant case, however, returns true if data is equivalent to null. Therefore, these two versions are not equivalent",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
31,296,15,SUBMITTED,yes,"As isXmlDeclarationData isn’t null-safe, if data can be null, then behavior changes. In the mutant code, if data is null, we’d get true instead of NullPointerException. However, when I exaed the getData() method, the problem solely depends on the value attribute. If the value is null, then the data is null, and finally, behavior changes, as described above. String data = null; Comment comment = new Comment(data);, which is a valid code. Data can be null under some conditions, so this change caused a bug that changed the output and behavior of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
34,302,3,SUBMITTED,no,"Both conditions achieve the same result of detering whether argName has content, so the modification doesn't introduce any bugs.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
91,302,7,SUBMITTED,no,"Both mutant and original code has the same behavior, which is to check if the argument is empty, which is the same as checking if the length of argument is not zero.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
64,302,8,SUBMITTED,no,!argName.isEmpty() and argName.length() > 0 are equivalent conditions and will output the same results,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
2,302,6,SUBMITTED,no,!argName.isEmpty() and argName.length() > 0 are the same.,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
62,305,6,SUBMITTED,yes,codebert-base.commons-codec.mid-38.idx-590.2.mutant,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
105,305,0,SUBMITTED,yes,"The mutant changes the behavior of the constructor by reversing the doEncode parameter, causing the stream to encode when it should decode and vice versa. This is a significant behavioral change and constitutes a bug. For example, if the constructor is intended to initialize a stream for decoding when doEncode is false, the mutant will incorrectly initialize it for encoding. (Note that the mutant would not be buggy if the stream's behavior was intended to be reversed in this context.)",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
55,308,22,SUBMITTED,no,"The mutant code does an explicit null check with if (indexProducer == null) and throws NullPointerException, unlike the original code, which uses Objects.requireNonNull() to check for null indexProducer. However, the overall behavior and functionality of the code remains same and only the null check handling is different. Thus, the mutant code is not buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
5,308,18,SUBMITTED,no,"The mutant code has changed the behavior of the merge method. In the original code, it uses Objects.requireNonNull(indexProducer, ""indexProducer"") to check if indexProducer is null. If indexProducer is null, it throws a NullPointerException with the message ""indexProducer"".  In the mutant code, it uses a simple null check if (indexProducer == null). If indexProducer is null, it throws a NullPointerException with the message ""indexProducer is null"".  The change in behavior is imal and mostly related to the error message provided when indexProducer is null. The original code provides a more concise error message, while the mutant code provides a slightly more descriptive one.  This change in behavior is unlikely to introduce bugs, as both versions correctly handle the case where indexProducer is null by throwing a NullPointerException",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
9,312,9,SUBMITTED,no,Not a Bug,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
89,312,19,SUBMITTED,no,"Although the original code runs from i=0 to iCount and mutant code runs from i=iCount to 1, the code is not buggy. This is because the variable i is not used anywhere in the code and loops in both the code have equal number of iterations e.g. if iCount is 10, iClosure.execute(input) will be executed 10 times in both the codes.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
93,313,7,SUBMITTED,yes,"Correct code might lead to NullPointerException, unlike mutant code if iPredicate is null.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
85,313,2,SUBMITTED,yes,,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
31,313,15,SUBMITTED,yes,"iPredicate is a final member variable, and its value is assigned in the constructor. However, the constructor doesn’t do any null validation. Hence, if someone calls the class with the code NotPredicate<T> notPredicate = new NotPredicate<T>(null); , T being any class type, then iPredicate will always be null, and evaluate() function would throw NullPointerException. On the other hand, the mutant code returns false, instead of throwing an exception. Therefore, the mutant code changed the code’s output and behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
48,314,10,SUBMITTED,yes,"In the original code, the for loop begins with 'i = 0' while in the mutant code it begins with 'i =iPredicates.length - 1'. In the original code, the value of 'i' is increased by 1 with each step but in the mutant code its decreased by 1 in each step. Therefore the values of 'i' are different in both the codes and so the mutant code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
34,314,3,SUBMITTED,no,"The modified code reverses the loop iteration from i = 0; i < iPredicates.length to i = iPredicates.length - 1; i >= 0. This change ensures that the transformers corresponding to the later predicates are checked first. If the predicates and transformers are ordered correctly, this modification should not introduce a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
13,314,9,SUBMITTED,no,"The mutant code starts from the end of the array and indexes till the begining while the original starts form the start of the array till the end, the code is equivilent and will not make a difference.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
23,329,4,SUBMITTED,yes,The actual code doesn't check about null values but the mutant does. Although its good to handle the null values but it does comply with the same behavior of the actual code. That's why its a bug.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
96,329,2,SUBMITTED,no,Output is the same,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
106,329,2,SUBMITTED,no,"both original and mutant return the element at key, and if there isn't anything there it returns null",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
105,331,0,SUBMITTED,yes,"The mutant changes the behavior of the isEmpty method by incorrectly returning true when it finds an empty element in the composite array. This could cause the method to return true prematurely. The original code correctly returns false if any element is not empty and true only if all elements are empty. The mutant's behavior is incorrect as it doesn't accurately reflect whether the composite array is fully empty or not. For instance, if arr contains [1, null, 4, 3, null], the original code returns false, but the mutant returns true.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
86,331,6,SUBMITTED,yes,Continue means it might return true next instead of instantly returning false. Which is an incorrect result.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
20,331,13,SUBMITTED,no,"The original code checks if any of the array cells is empty then it returns true and the for loop terates  otherwise it returns false. In the mutant code, if a non-empty cell is found, then the continue statement is executed and the rest of the iteration is skipped. If it founds an empty cell then it returns true outside the if statement. If the for loop iterates through the array and didn't return anything then that means there are no empty cells and the method returns false.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
78,332,9,SUBMITTED,no,it will clear composite in different orders. So result remains same,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
55,332,22,SUBMITTED,no,"While the mutant clears the array elements in a reversed order, the end result is the same. Thus, the mutant is not buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
30,332,10,SUBMITTED,no,"Although the order of loops changes and loop iterators count forward, the number of times the if condition is executed is not changed, and it always clears or performs some form of cleanup on each element in the composite array.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
5,338,18,SUBMITTED,yes,"The mutant code has changed the behavior of the checkMod method. In the original code, if the modCount of the parent map is not equal to expectedModCount, it throws a ConcurrentModificationException.  In the mutant code, it only throws a ConcurrentModificationException if the modCount of the parent map is greater than expectedModCount.  This change in behavior could lead to bugs, as the method no longer detects when the modCount of the parent map is less than expectedModCount. This could happen if the map was somehow reverted to a previous state.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
21,338,6,SUBMITTED,yes,"In the main code, you are checking if parent.modCount is different than expectedModCount. However, in the mutated code you are checking if parent.modCount is greater than expectedModCount",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
37,341,6,SUBMITTED,no,Equality comparison is definitely commutative if not implemented otherwise.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
62,341,6,SUBMITTED,yes,The original code checks for equality (key1 == key2). Swapping the operands changes the logic. It now checks if key2 is equal to key1 instead.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
72,341,5,SUBMITTED,no,"The operands are swapped in a test of equality, but this does not change the evaluation of the expression.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
82,342,2,SUBMITTED,yes,The method should return an empty list iff the call to getMap().remove(key) returns null. The mutant code will always return null (not a List).,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
42,342,15,SUBMITTED,yes,it will always return null instead of checking if it is empty or not,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
51,342,15,SUBMITTED,yes,"The correct version provides more information by returning list of values for corresponding key if there exists or empty list if null( no corresponding value). While the mutant simply always returns null, regardless of weather the key existed or not.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
53,343,13,SUBMITTED,yes,"getMap().remove(key) only returns null when the key is not found in the map. In the second code snippet (Mutant), we replace getMap().remove(key) with null, which would lead to an empty list being returned all the time, even when the key is part of the List",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
78,343,9,SUBMITTED,yes,It changes behavior and result of the code and it will always return empty list without removing values,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
45,344,30,SUBMITTED,yes,The mutant code will result in a runtime exception -throws ArithmeticException-. Java does not support when an integer is divided by 0.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
9,344,9,SUBMITTED,yes,Curlybrace not closed properly.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
35,353,6,SUBMITTED,yes,The valid indices includes 0 but the mutated code is eliating it.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
34,353,3,SUBMITTED,yes,"The modified code introduces a bug because it changes the condition from bitIndex >= 0 to bitIndex > 0. This modification makes the method return false for bitIndex = 0, whereas in the original code, 0 was considered a valid bit index. Therefore, the modified code incorrectly excludes 0 from the valid range of bit indices.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
66,354,14,SUBMITTED,yes,The mutated code simply returns false for the containsValue so the mutated code is incorrect while in actual code it is return  containsValue which may be true and false,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
61,354,4,SUBMITTED,yes,First is if value then true else false while second is always false,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
72,361,5,SUBMITTED,yes,The function is a helper function to read the argument (an array of bytes) as a long value. Only passing the null argument negates the purpose of this.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
16,361,7,SUBMITTED,yes,This change in behavior introduced by the mutated version is likely unintentional and could be considered a bug. It effectively breaks the functionality of the method by not using the provided byte array to retrieve the long value.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
90,361,5,SUBMITTED,yes,"The modification in the getLongValue(final byte[] bytes) method within the ZipEightByteInteger class, which changes the argument from the bytes array to null, results in a code alteration that will consistently cause a NullPointerException at runtime. This fault significantly impairs the functionality, transitioning from a method that properly retrieves a long value from a byte array to one that will fail upon every invocation.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
12,363,3,SUBMITTED,yes,returns 0 in all cases,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
19,363,2,SUBMITTED,yes,return value is always 0 instead of the number of bytes read,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
81,364,15,SUBMITTED,yes,"The change increases the total number of 100-nanosecond intervals by one before adjusting for the Windows epoch offset. In practical terms, this means the resulting NTFS timestamp will represent a time that is 100 nanoseconds later than it would without this addition.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
64,364,8,SUBMITTED,yes,It is a bug since we are adding a 1 in javaHundredNanos + 1,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
6,368,11,SUBMITTED,yes,It could lead to a null pointer exception,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
24,368,3,SUBMITTED,yes,"when baseValue is null, the mutated version returns ValueUtils.getLength(baseValue) + 1, which might result in a NullPointerException",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
20,371,13,SUBMITTED,no,Returning the boolean expression in the original code will do the same as using if else statement in the mutant code,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
86,371,6,SUBMITTED,no,Just expanded the single liner conditional.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
29,373,2,SUBMITTED,yes,"Ternary conditional operator takes the following form:  <EXP_1> ? <EXP_2> : <EXP_3>. After its evaluation the result is <EXP_2> if <EXP_1> is true and <EXP_3> if <EXP_1> is false. In our case <EXP_1> corresponds to the ""includeXmlLang && position == 1"" (original code) and ""includeXmlLang || position == 1"" (mutated code). If mutated code doesn't contain bug then the original and mutated code would return the same value for all possible boolean pairs (values of ""includeXmlLang"" and ""position == 1""). Let's assume that  both ""includeXmlLang"" and ""position == 1"" are true. As a result: (1) Original code would return ""new LangAttributePointer(parent)"" (2) Mutated code would return ""super.getNodePointer()"". Therefore, by counterexample we can deduce that original and mutated code are not equivalent, hence the mutated code contains bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
76,373,12,SUBMITTED,yes,"In the original code, it returns new LangAttributePointer(parent) only if both conditions (includeXmlLang && position == 1) are true. In the mutant code, it returns new LangAttributePointer(parent) if both conditions are false.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
24,374,3,SUBMITTED,yes,The modification from position == 1 to position == 0  means that the new LangAttributePointer(parent) will be returned when includeXmlLang is true and position is 0.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
45,374,30,SUBMITTED,yes,"According to XML Path Language (XPath), the first proximity position is 1. Therefore, the mutant version is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
10,379,8,SUBMITTED,yes,"The mutant toggles the current flag 'useFieldNames' instead of setting its value. In case the current value of the flag is true, and if we run the concerned function with the parameter 'true', the mutant would set the flag to false (opposite of the current value), whereas the original code would set it to true. Hence, the outcomes of the mutant are opposite to the original code in a few cases.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
28,379,5,SUBMITTED,yes,"as it returns the opposite of the super,useFieldNames while the original code it setting the super.useFieldNames with the exact value it passed in the parameters of the function",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
41,379,7,SUBMITTED,yes,output will be different as value on both ends in super.setUseFieldNames() method is different.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
81,381,15,SUBMITTED,yes,The original code passes (to the super class) the input of the function while the mutant code always return false because any value && false is false.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
4,381,1,SUBMITTED,yes,"The parameter passed in the first code is useIdentityHashCode, while the parameter passed in the second code is false as (useIdentityHashCode && false) = false",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
82,382,2,SUBMITTED,yes,"Instead of return the result of super isDefaultFullDetail method, the code always return true.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
58,382,9,SUBMITTED,yes,The isDefaultFullDetail() method is set to always return true. If the method is supposed to return true or false depending on some condition then the mutant code is a bug since it ignores any prior logic used and always returns true.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
55,384,22,SUBMITTED,yes,"The original code sets shiftCount to 0 when mask is 0, while the mutant code sets shiftCount to the number of leading zeros in the mask.  It modifies the calculation of shiftCount when mask is equal to 0 and introduces a different behavior that deviates from the original code's functionality.Thus, the mutant is buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
40,384,4,SUBMITTED,yes,"The mutated code will produce different output as of the original code. In the mutated code, when the mask is 0, the shiftCount is detered by the number of leading zeros (which by using Integer.numberOfLeadingZeros(0) outputs 32), whereas in the original code, it is always set to 0 in this case. Therefore, the mutated code produces a different output compared to the original code when the input mask is 0.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
31,384,15,SUBMITTED,yes,"If mask = 0, in the original code, shiftCount is assigned to 0, but in the mutant code, it is assigned to 32, the number of zeros until we encounter a one. Please note that Integer.numberOfLeadingZeros(mask) = 32, as specified in the source code. Hence, the mutant code changes the code’s output and behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
3,384,5,SUBMITTED,yes,"In the modified code, when the mask == 0, shiftCount will be 32 instead of 0 in the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
28,388,5,SUBMITTED,no,as both are assigning the ```this.daemon``` to the value of the passed argument final boolean daemon,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
80,388,2,SUBMITTED,no,"The original code assigns the boolean value of the passed argument “daemon” in the objects local variable of the same name. For this, it uses “Boolean.valueOf()” which can be termed as an unnecessary way to do so. It can be simplified via assigning the parameter boolean variable directly to the local variable. This is exactly what the mutant version implements. So I think this is not a bug in the traditional sense, it just an optimization of the older version of the code that produces the same result as before.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
14,395,4,SUBMITTED,yes,Creates an infinite loop,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
63,395,5,SUBMITTED,yes,The mutant is a bug as it creates an infinite while-loop inside the given method and does not even contain a return statement.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
102,397,10,SUBMITTED,yes,"The mutated code does not give the same deterministic output as the original code. The reason is that the original code uses float precision for the addition, while the mutated code uses double precision, which can lead to different results due to the differences in precision and range between float and double. This change affects the precision of the arithmetic operation and can lead to different outcomes.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
99,397,6,SUBMITTED,yes,"Float: 32-bit IEEE 754 floating point whereas,  Double: 64-bit IEEE 754 floating point. It has a larger range and greater precision than float. hence, may affect the result due to higher precision before casting back to float.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
30,398,10,SUBMITTED,no,"NaN is the only value for which the equality comparison with itself evaluates to false. As a result, both the original code and the mutated code check whether the float value is the special NaN value. And if the value is NaN, both codes will return true, if not, both codes will return false.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
99,398,6,SUBMITTED,no,"Both are checking whether value is NaN or not, a value is NaN when it is not equal to itself . hence both are correct",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
6,399,11,SUBMITTED,yes,the method subtracts the current value of this.value and assigns the result to this.value.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
104,399,5,SUBMITTED,yes,original has value this.value - operand.doubleValue(),6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
57,399,5,SUBMITTED,yes,The mutant replaces x -= y with x = y - x.  The mutant behaves differently when x is not equal to y.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
94,400,30,SUBMITTED,yes,The reversed order of subtraction can potentially lead to differing results if different values are passed to 'operand' during method calling.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
11,400,2,SUBMITTED,yes,The output will be with an inverse sign. the code should be  this.value = this.value - operand.floatValue(),6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
3,406,5,SUBMITTED,no,"In the modified code, the byte is first converted to string and then again to byte. While it might cause some performace issue, it will behave exactly the same.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
85,406,2,SUBMITTED,no,syntactic change,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
27,407,3,SUBMITTED,yes,"The mutant code is buggy because altering the method to return the square of the value instead of the decremented value itself changes the expected output and behavior of the method, diverging from its original purpose of simply decrementing and returning the new value.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
80,407,2,SUBMITTED,yes,"The original decrementAndGet() function decreases the value of the variable “value” by 1 and then returns the decreased value. Although the modified mutated decrementAndGet() function decreases the “value” variable correctly, it returns the square of the decreased variable instead. For example, given the value 2, the mutant should have returned 1, rather it returns 4. Hence, it is not correct as before.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
81,408,15,SUBMITTED,yes,"In the original code, if a non-numerical value is entered, the program will probably crash while in the mutant one, the exception is caught within the constructor, and the application continues to run smoothly without crashing, and a MutableInt object is created with a value of 0.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
91,408,7,SUBMITTED,yes,"In the original code is a NumberFormatException was found it would have been thrown, but in the mutant code it just returns that the value is 0.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
94,409,30,SUBMITTED,yes,"While the mutant code handles the NullException better, it doesn't check for whitespaces or empty strings and will throw a NullExceptionPointer if either are passed during method calling",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
69,409,4,SUBMITTED,yes,Mutant wont throw NumberFormatException if null string is passed. We are expecting the function to throw this error in the original code,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
12,409,3,SUBMITTED,no,improves upon original code by handling test case of no string being passed,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
29,412,2,SUBMITTED,yes,"Mutated code contains bug simply because the ""this.value -= operand"" which is equivalent to ""this.value = this.value - operand"" (original code) is nonequivalent to ""this.value = operand - this.value"" (mutated code).",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
76,412,12,SUBMITTED,yes,"The original code subtracts the operand from this.value, while the mutated version subtracts the this.value from the operand, which results in a completely different output.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
94,412,30,SUBMITTED,yes,"The order of subtraction is reversed compared to the original code, which could lead to different results if different values were assigned to 'operand'",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
79,414,2,SUBMITTED,yes,"In the original code, this.value += operand is used which is same as this.value = this.value + operand. But in case of mutant version, this.value = operand is used. So, unless this.value = 0, the mutant version will show different behavior from the original one. Therefore, the mutant is buggy here.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
4,414,1,SUBMITTED,yes,"In the first code, we increase value by operand. While in the second code, we make value = operand",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
97,416,2,SUBMITTED,no,they both return empty arrays. the first one returns an immutable one while the second one n be changed,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
47,416,6,SUBMITTED,no,The initial utils would return the same object as defining a new one,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
72,417,5,SUBMITTED,no,"According to comment above snippet, ""The arguments may be passed in the order (,max) or (max,)"". The range object created will have the same imum and maximum.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
63,417,5,SUBMITTED,yes,"Here, the ""of"" method in the mutant is calling the overloaded ""of"" method with the parameters in a swapped order (to, from instead of from, to). This changes the behavior of the code and hence, the mutant is a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
85,417,2,SUBMITTED,no,,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
93,418,7,SUBMITTED,yes,"In mutant code, constructor is called with different parameters.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
68,418,18,SUBMITTED,yes,value should be 0 in this case,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
73,420,4,SUBMITTED,yes,The == operator in the mutated snippet compares the addresses of the object while in the original snippet equals method compares the values of the objects.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
12,420,3,SUBMITTED,yes,object.equals() compares only structure of object whereas == compares value stored in object,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
103,420,6,SUBMITTED,yes,"The mutant is buggy because == checks if the references is the same while equals method checks if the contents are the same for the two objects. Depending on whether or not they have the same or different contents, or different references the answers will not always be the same.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
25,420,2,SUBMITTED,yes,"The original code compares the values of the objects meanwhile the mutant code compares the memory location of the objects, which are not same for reference data types",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
86,428,6,SUBMITTED,yes,“Generates a random long within 0 - Long.MAX_VALUE” - and Long._VALUE is below 0.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
51,428,15,SUBMITTED,yes,"from the comments it is inferred as the nextlong(n) accepts only postive bound, so taking long._value is not possible as it is a very small large magnitude negative number",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
104,431,5,SUBMITTED,no,Mutant is written out version of function,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
4,431,1,SUBMITTED,no,I think function Objects.requireNonNull handles the exceptions as done be the conditions in the second code.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
46,432,2,SUBMITTED,no,"In the original code, the 'requireNonNull' checks that the specified object reference is not null and throws a customized NullPointerException if it is. In the mutant code it only checks that the specified object reference is not null. It does not throw a customized NullPointerException, but a default one. The code will run just the same in both the conditions. Hence the mutant code is not buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
91,432,7,SUBMITTED,no,"Both mutant and original code will throw an exception when the inputed object is null, but the only difference is that the original will output ""set"" when the exception is thrown.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
14,433,4,SUBMITTED,yes,return value of buggy code will be 1 more that the actual value due to addition,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
77,433,3,SUBMITTED,yes,It attempts to return the hash code of bitSet plus 1 if bitSet is not null.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
31,436,15,SUBMITTED,yes,"Let’s see by the easiest example, these two codes are not equivalent. If we look at the nextDouble implementation, we see that the function can return at least the first parameter large. It’s no longer possible to generate a 0 out of this function, since Double._NORMAL is the smallest positive double value. Hence, the mutant code changes the code’s output and behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
5,436,18,SUBMITTED,yes,"The mutant code has changed the behavior of the nextDouble method. In the original code, the method generates a random double between 0 and Double.MAX_VALUE. In the mutant code, the method generates a random double between Double._NORMAL and Double.MAX_VALUE.  Double._NORMAL is the smallest positive nonzero value of type double, which is greater than zero. This means that the range of possible values generated by the mutant code is slightly larger than the range of the original code.  This change in behavior could lead to unexpected results if the code calling nextDouble is not expecting to receive a value less than zero.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
32,442,20,SUBMITTED,yes,"In the original case, the method returns the same boolean value passed as an argument. But in the mutated case the method always returns true. This changes the output and the expected behaviour of the original code thus causing a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
7,442,15,SUBMITTED,yes,Any result will return true when performed logical OR operation with 'true'. It introduces bugs when the value is false because it returns true.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
14,442,4,SUBMITTED,yes,Buggy code always returns true,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
79,444,2,SUBMITTED,no,"In the original case, Arrays.sort(array) is used which sorts the array in place. In the mutant version, the array is copied to another array ""sortedArray"" first and then sorted using Arrays.sort(sortedArray). Eventually both versions of the code do the same thing which is to sort the array. Therefore, there is no difference in code behavior and the mutant is not buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
53,444,13,SUBMITTED,yes,"The code is supposed to sort the array in place , but the mutant creates a new array which is then sorted while leaving the initial array unsorted",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
15,444,4,SUBMITTED,yes,"In the original code, the sorting occurs in place, while in the mutant, the sorting happens on a copy of the original array, so the original array stays unsorted",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
38,452,1,SUBMITTED,yes,the mutant code replaces the multiply function with the add function but this defeats the purpose of the function which is to multiply two BigReal objects,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
76,452,12,SUBMITTED,yes,"The mutant applies a new operation i.e division instead of multiplication, changing the result it returns completely",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
23,452,4,SUBMITTED,yes,"As the operation type is changed from multiplication to addition, its a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
10,452,8,SUBMITTED,yes,"The mutant uses the add function of the BigDecimal class in Java for a function meant to multiply. Hence, for the same input, the original code would use the multiply function of the BigDecimal class and return the product, while the mutant would return the addition",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
27,453,3,SUBMITTED,yes,"The mutated code is buggy that the mutated code attempts to access an array beyond its intended range by adding 1 to the “len” parameter, which could lead to accessing data outside the array bounds and potentially cause an “ArrayIndexOutOfBoundsException”.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
62,453,6,SUBMITTED,yes,he mutant includes one extra character during BigDecimal creation which can lead to parsing errors if the input doesn't accommodate the additional character.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
89,453,19,SUBMITTED,yes,"Increasing the length by 1 increases the length of the slice to be analyzed. For example if the number was 1.5432, having an offset of 0 and length of 3 will return 1.5 whereas a length of 4 will return 1.54 .",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
86,453,6,SUBMITTED,yes,len length of the array slice to analyze so len+1 can create segmentation faults.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
97,456,2,SUBMITTED,yes,They both return different numbers unless the interpolatedTime is null value of,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
63,456,5,SUBMITTED,yes,"The mutant is a bug because the method, instead of simply returning the variable ""interpolatedTime"", is subtracting 1 from it and then returning the value.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
90,457,5,SUBMITTED,yes,"The edited code introduces a bug by doubling the value of interpolatedTime in the getInterpolatedTime() method. This modification alters the intended behavior by incorrectly scaling the time value, potentially leading to incorrect interpolations or results based on this time value.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
50,457,8,SUBMITTED,yes,The mutant code is multiplying the interPolatedTime by 2 before returning it,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
79,458,2,SUBMITTED,yes,"In the original code, the hashcode is generated by multiplying the value to 31 and adding it to the key. But in the mutant version, the hashcode is generated by multiplying the key to 31 and additing it to the value. Therefore, certainly the hashcode will be different unless the key and the value are the same.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
20,458,13,SUBMITTED,yes,"In java and most programg languages multiplication has higher  Precedence over addition Therefore, In the original code 31 is multiplied by Arrays.hashCode(getKey()) and then added to  Double.hashCode(getValue().  Meanwhile, in the mutant code, 31 is multiplied by  Double.hashCode(getValue()) first and then added to Arrays.hashCode(getKey()) which will give totally new output.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
50,458,8,SUBMITTED,no,Both the original and mutant code will return same hashresult due to the choice 31 as the multiplier,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
54,461,6,SUBMITTED,yes,"The mutant code always returns the first element of the values array, which in most cases isnt sufficient to calculate the geometric mean. Only when the array contains 1 element will this work, otherwise it wont. So its not reliable, hence, its buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
27,461,3,SUBMITTED,yes,"The mutant code is buggy because the geometric mean calculation to just return the first array element or “Double.NaN”, ignoring the correct mathematical process to compute the geometric mean, which significantly alters the expected outcome and provides incorrect results.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
64,462,8,SUBMITTED,yes,The function is changed as we are now adding NAN means undefined value.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
90,462,5,SUBMITTED,yes,"The edited code introduces a bug by incrementing with Double.NaN instead of the given value, which corrupts the calculation of geometric mean, making it always NaN.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
54,465,6,SUBMITTED,yes,"Adding (1) to the length would cause problems. As arrays are 0-indexed, adding an extra index will cause the ptr to go out of bounds, therefore, the mutant is buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
44,465,45,SUBMITTED,yes,"The buggy code is indeed buggy. In the original (mutant) code, the Std constructor takes an array inputDocument and calls another constructor with inputDocument, 0, and inputDocument.length + 1 as arguments.  In the buggy code, the Std constructor also takes an array inputDocument but calls another constructor with inputDocument, inputDocument.length, and 0 as arguments. This is a significant change in behavior from the original code, making the buggy code buggy. The original constructor should start at index 0 and go up to inputDocument.length + 1, not start at inputDocument.length and go to 0. So, yes, the buggy code is really buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
35,465,6,SUBMITTED,yes,The mutated code is trying to read more bytes than available,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
24,467,3,SUBMITTED,yes,"The RHS code introduces a bug by using an uninitialized array element as the offset, causing incorrect data to be written.",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
74,467,2,SUBMITTED,maybe,"Since I do not know the value of offset, so can't really tell",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
39,467,3,SUBMITTED,yes,arr[1] is out of bound since the size of the array is only 1 and int arr is indexed from 0.,6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
25,468,2,SUBMITTED,yes,The method in the mutant version always returns -1 which is not the same as the behavior in the original code,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
99,468,6,SUBMITTED,yes,"The mutated version introduces a significant bug because it completely bypasses the reading logic. By always returning -1, it prevents the method from ever reading data from _b or _in.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
77,468,3,SUBMITTED,no,Both are correct in which the mutant is suitable for scenarios where the stream is empty or has been fully read.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
100,470,3,SUBMITTED,yes,Need not always be false (_b and _in are independently supplied),6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
51,470,15,SUBMITTED,yes,as both _b=null and in.marksupported need to be zero always for the mutated too result the same as the correct one.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
18,471,3,SUBMITTED,yes,"Whether _in.markSupported returns depends on the Input Stream, therefore it can be false even though _b is null. Hence mutated version would return true even if it is meant to be false.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
35,471,6,SUBMITTED,yes,The _in.marksupported() can or cannot return true.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
60,471,8,SUBMITTED,no,_b is guaranteed to be not null due to the explicit constructor so it will return the same values.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
49,475,10,SUBMITTED,yes,- Buggy In the original code the value of k - K_ is left shifted by 1 before accessing the array element at this value. In the mutant the value of f k - K_ is left shifted by 1 and then 1 is added to it before accessing the array element at this value.Thus the mutant is buggy.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
45,475,30,SUBMITTED,yes,"It is a buggy mutant that changes the output of the code since ""+"" has higher precedence than ""<<"", the code will not be evaluated as expected.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
36,476,4,SUBMITTED,yes,In the original code a left shift operator is used along with the subtraction as compared to only a subtraction in the mutant which can return different values.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
76,476,12,SUBMITTED,yes,The original code accesses the elements that is twice the distance from (k-K_) but the modified mutation only accesses the (k-K_)th position without any offsetting.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
42,481,15,SUBMITTED,yes,it will write wrong length of array and put numbers in wrong positions,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
90,481,5,SUBMITTED,yes,"The edited code introduces a bug by changing the third parameter to offset + length, likely leading to incorrect array element writing beyond the intended range, altering the method's intended behavior and causing errors.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
73,481,4,SUBMITTED,yes,"In the mutated code, the value of length variable is changed from value of input parameter 'length' to sum of input parameters of method - 'offset' and 'length', thus changing snippet output.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
21,483,6,SUBMITTED,yes,"The .lowercase() method changes the String to ""name"" instead of ""Name"" for example.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
103,483,6,SUBMITTED,yes,The mutant is buggy because the string could contain capital letters such as “Name” which would write the field name as “Name” while on the right it would write “name” since it turns the string into all lowercase,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
28,484,5,SUBMITTED,yes,as the delegateCopyMethods == True then   this.delegateCopyMethods=false and this is the opposite from making this.delegateCopyMethods == delegateCopyMethods,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
79,484,2,SUBMITTED,yes,"Here, initially delegateCopyMethods is false by default as it is an boolean. In the original code, class member variable delegateCopyMethods is set to the value of parameter delegateCopyMethods. That means, if delegateCopyMethods is true if the parameter is true otherwise it is false. But in case of the mutant method, the behavior is opposite where delegateCopyMethods is assigned to false when the parameter is true. Therefore, the mutant is buggy. It would be fine if the mutant code was like this,  	if (delegateCopyMethods) 		{this.delegateCopyMethods = true;}",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
48,485,10,SUBMITTED,yes,"In the original code, its given that '_streamReadFeatures' is equal to itself and 'f.mappedFeature().getMask()'. However in the mutant, the value of the variable is '_streamReadFeatures + f.mappedFeature().getMask()', which could have a different value from that of the original code. Therefore the code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
98,485,4,SUBMITTED,yes,"The variable is assigned its value according to bitwise and in the left side and  bitwise or in the right side, which will cause a different value to be stored to it in any case where both bytes have a 0.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
8,491,6,SUBMITTED,yes,"Here in the mutant code, there is change in _allowJDKTypeCtors parameter from “false” to “true”, this definitely change the output and behavior of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
58,491,9,SUBMITTED,yes,"In the mutant code the allowJDKTypeCtors is set as true in this statement this(singleArgMode, false, false);  to allow JDK constructors. This will alter the behavior of the code hence its a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
67,496,15,SUBMITTED,yes,"When i checked the configure function, it is clear that this mutant code is buggy actually, when we call it with the negated state.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
29,496,2,SUBMITTED,yes,"Since the mutated code passes different state (flipped state) to the ""_mapper.configure()"" than provided and the original code passes the unchanged state we can deduce that mutated code contains bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
25,498,2,SUBMITTED,yes,"The original code is passing a variable from a class that contains the value whether annotation processing is enabled, meanwhile the mutated code is referencing an unrelated variable",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
8,498,6,SUBMITTED,yes,"As the method isAnnotationProcessingEnabled() suggest to check if Annotation is enabled or disabled, here in the mutant code, it is checking on the basis of Access-Modifiers instead of Annotation, this can lead to change of method logic hence producing bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
29,499,2,SUBMITTED,yes,"Assug that the original code is correct which implies that the ""_viewMatcher"" should be set to null only and only if the value of ""views"" is null, we can deduce that the mutated code contains bug because the value of ""_viewMatcher"" is set to null regardless of the value of the variable ""views"".",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
2,499,6,SUBMITTED,no,"The variable viewMatcher will be reassigned, and the initial assignment does not affect it.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
65,499,12,SUBMITTED,no,"After constructing the '_viewMatcher' object with 'ViewMatcher.construct(views)', the next line '_viewMatcher.toString();' is calling the toString() method on the _viewMatcher object, but the result is not being used or assigned to anything. And after that _viewMatcher object is set to null so we have no significance for '_viewMatcher.toString();'.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
99,501,6,SUBMITTED,no,"In Java, the logical AND operator (&&) has left-to-right associativity and the same precedence whether or not parentheses are used around individual conditions. Hence, both original and mutated code will be evaluated in the same way.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
36,501,4,SUBMITTED,no,Due to short circuiting in Java only the left side operand is evaluated first irrespective of the usage of parenthesis.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
47,501,6,SUBMITTED,no,The paranthesis has no effect in the mutant scenario.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
72,504,5,SUBMITTED,no,"The object handled by the generator may not have any properties named as the empty string, but the function's output will contradict this.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
40,504,4,SUBMITTED,no,"The mutated code will produce same output than the original code. The added condition name.equals("""") in the mutated code does not affect the behavior because it is part of a logical OR expression. The method will return true only if name is an empty string, and in that case, it will not evaluate the second part of the OR expression due to short-circuiting. If name is not an empty string, it will proceed to generator.isValidReferencePropertyName() as in the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
49,507,10,SUBMITTED,maybe,The codeline _referringProperties = new LinkedList<Referring>(); that is added to the mutant is making a change to a class variable _referringProperties (as denoted by the underscore before it). It is difficult to say if the 2 are logically equivalent without seeing the rest of the code.,6/26/2024 3:46,6/26/2024 3:46,0,1,1,2,4,yes,1/1/2002
30,507,10,SUBMITTED,yes,"The original code set _referringProperties to null, while with “_referringProperties = new LinkedList<Referring>();” in mutated code, the variable is assigned a reference to the newly created object, and it will not be null.",6/26/2024 3:46,6/26/2024 3:46,0,1,1,2,4,yes,1/1/2002
83,507,9,SUBMITTED,yes,"There are two differences in the codes. The first difference is: the original code checks if _referringProperties is not null, while the buggy code does the opposite, which negates the purpose of the check. The second difference is: the original code correctly handles when _referringProperties is empty, it doesn’t get into the condition, rather it creates a  new LinkedList<Referring>(). The buggy code doesn’t handle this part at all since the first check is done incorrectly.",6/26/2024 3:46,6/26/2024 3:46,0,1,1,2,4,yes,1/1/2002
10,507,8,SUBMITTED,no,"Both the mutant and the original code perform the same task. When binding the unresolved forward references, the LinkedList '_referringProperties' is made null in both cases. The mutant simply reinitializes the LinkedList at the end. Therefore, the mutant is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,1,1,2,4,yes,1/1/2002
7,508,15,SUBMITTED,no,"The both code are same, only formatting is different.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
101,508,6,SUBMITTED,no,"No. The only difference in the mutant version is that the format of one line is different and a comment was added. But since the comment was NOT implemented, as it states variable _valueInstantiator should not be set to valueInstantiator which is not the same as the original version, these two versions remain equivalent in functionality.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
36,514,4,SUBMITTED,yes,The criteria for is different in the original and the mutant.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
25,514,2,SUBMITTED,yes,"The original code checks whether the method returns a boolean or not, meanwhile the mutated code has a logical OR operator that checks whether the method returns a boolean or number. Therefore, this would return an uncertain and wrong result",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
106,516,2,SUBMITTED,yes,"the muted version checks for the index to be greater or equal to the length +1, which can result in an index out of bounds",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
43,516,4,SUBMITTED,yes,"The original code returns null if 'index >= types.length', but the mutated code returns null under a completely opposite condition. Therefore, they don't work the same.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
74,516,2,SUBMITTED,yes,Adding +1 with the code length will change the number of return values,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
8,524,6,SUBMITTED,yes,"The function isBinary() suggests to check for the NodeType() to be binary of not, but in the mutant code, there is “OR” logic that checks for NodeType() to be number. This additional logic is prone to be buggy because isBinary will be true when ( either getNodeType() is Binary OR Number).",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
7,524,15,SUBMITTED,yes,The condition in the mutant is expanded to check for the numbers too. So it results in bug in some cases.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
49,526,10,SUBMITTED,no,"They are logically equivalent statements as the number that “_value.stripTrailingZeros().scale()”  can have possible values of zero or greater only. Thus in the case where the element has no decimal value and is a integral number, both code snippets will return true",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
17,526,30,SUBMITTED,no,"Since the scale cannot be less than 0 and trailing zeros are removed before scaling, the equality and less than or equal signs will resolve to the same value",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
26,527,8,SUBMITTED,yes,"unscaledValue() never returns null, but scale() may be greater than zero.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
105,527,0,SUBMITTED,yes,"The mutant changes the condition to check if _value.stripTrailingZeros().unscaledValue() == null, which is incorrect. The original code correctly checks the scale of the stripped value, while the mutant introduces a null check that is not logically equivalent, leading to incorrect behavior. The unscaledValue() function does not return null, but also returns the entire number. The operation itself changes by returning the number of digits to the right of the decimal point.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
92,527,21,SUBMITTED,yes,"In the mutated code, the third condition checks if `_value.stripTrailingZeros().unscaledValue() == null`. This is incorrect because the `unscaledValue()` method of `BigDecimal` returns a `BigInteger`, representing the integer part of `_value`. This `BigInteger` will never be null because `BigDecimal` always represents a numerical value, even if it is 0. Therefore, this condition will always return false, unless `_value` itself is null, but in this case, invoking `_value.signum()` would already throw a NullPointerException.  Hence, the mutated code is not only logically incorrect, but it also introduces a potential error: if `_value` is null, attempting to call `_value.signum()` would result in an exception.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
1,530,2,SUBMITTED,yes,"Seems to be a compilation error. If not, still for size ==0, it is not clear what it will return",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
67,530,15,SUBMITTED,yes,"If size is 0 than it will give error. When I look at, whether or not the size can get value 0, I realized that the size() function returns size of a java.utils.map which can be zero actually.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
66,530,14,SUBMITTED,no,original code is directly  return _sharedMap.size() while mutated code indirectly returning the same return _sharedMap.size() but using different code first entering,6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
17,530,30,SUBMITTED,yes,"The size function does not return any value when the size is greater than zero, however, the function expects an integer response",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
96,537,2,SUBMITTED,yes,Logic is wrong,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
16,537,7,SUBMITTED,yes,Change of behaviour when length=0,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
59,540,2,SUBMITTED,no,"For null value, both codes will stop working",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
60,540,8,SUBMITTED,no,Unnecessary check but works.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
23,543,4,SUBMITTED,yes,The output of the mutant code is just opposite of the actual as the default value of the asBoolean is True. Also the return value is the negation of overloaded asBoolean() function value.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
50,543,8,SUBMITTED,no,"Based on the asBoolean logic which return the defaultValue being passed to it, the original will return false while the mutant will also return false because it's negating the result just before it returns it",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
47,543,6,SUBMITTED,no,In both scenarios the logical flow is same,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
48,546,10,SUBMITTED,yes,"In the original code, 'this' is converted into a 'StandardEntityCollection' object only if it is an instance of 'StandardEntityCollection'. However in the mutant code, the same is done without checking if 'this' is an instance of 'StandardEntityCollection'. This can result in error and hence the mutant code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
66,546,14,SUBMITTED,yes,"it is bug ,but maybe it can give right answer in some cases because in some condition it can show some right answeror give right answer ,because in originl code 'obj' checks instance yes and returns true ,then it checks instance StandardEntityCollection if this is true then it checks compares the entities field using Objects.equals Mutated Code:if obj is null return false then it directly jums to comparing enteties here is the bug because in some condition it may give the desired output according to given condition but in most cases it can fail yes e are not checking the obj instance this and directly jug in The mutated code assumes that obj is not null and directly attempts to cast it to StandardEntityCollection.  and one more problem when we compare object to itself this it will always return false this is problem",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
69,549,4,SUBMITTED,yes,Mutant refers to the string DEFAULT_TEMPLATE while original code refers to the variable DEFAULT_TEMPLATE,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
52,549,36,SUBMITTED,yes,"I think it will be a buggy code as the snippet used a literal string which was written in double quotes, but the right one is to right the it without double quotes to refer to the static final variable that contains the actual template.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
100,552,3,SUBMITTED,no,"The object is not being referred to by anything else, so clearing is the same as assiging a blank HashMap.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
101,552,6,SUBMITTED,no,"No. While the mutant version creates a new instance of a hash map, it will act the same as the original since both are empty hash maps.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
105,552,0,SUBMITTED,no,"HashMap's clear() and creation of a new HashMap exhibit almost identical behavior. The difference is that creating a new HashMap results in the creation of a new object. This can cause an overhead due to object creation. Performance-wise, using clear() is advantageous unless it is necessary to completely remove the original map.  Additionally, the reason object mismatch does not occur is that there are no cases in the entire code where the map is used, as shown in the example above. Therefore, the behavior is the same.  Although replacing the indexMap with a new HashMap instance could potentially lead to inconsistencies if other parts of the code still hold references to the old indexMap instance, it generally results in similar behavior to clear(). The difference lies in performance, as creating a new object incurs more overhead. In the context of the whole code, the change does not introduce a significant issue since such usage scenarios are not present.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
8,554,6,SUBMITTED,yes,"In the mutant code, there is inversion of logic of the isEmpty() method, which leads to incorrect behavior in scenarios where the collection datatype should be considered empty.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
58,554,9,SUBMITTED,yes,"In the original code the method returns true only if getItemCount() returns 0 however in the mutant the method returns true only if getItemCount() returns any value other than 0. The mutant inverts the actual logic and would change output, hence its a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
95,557,68,SUBMITTED,no,Similar to original,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
33,557,4,SUBMITTED,yes,"This is because in the mutant snippet, year is called instead of yearOfEra, hence will return a copy of date time with the year field instead of datetime with the year of era field.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
41,557,7,SUBMITTED,yes,parameter to the right is chained as a method with getChronology() whilst year method is chained to getChronology() to the right hence output will be different for both.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
95,558,68,SUBMITTED,no,Similar to original,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
98,558,4,SUBMITTED,no,The left and right side are semantiaclly the same beause the left side always returns true and the right side always returns the evaluation of 1==1 which will alwlays evaluate to true.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
57,563,5,SUBMITTED,yes,"The mutant returns (MILLIS_PER_YEAR / 3) instead of (MILLIS_PER_YEAR / 2).  Since MILLIS_PER_YEAR is a constant, the mutant always behaves differently.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
77,563,3,SUBMITTED,yes,The divisor is not correct.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
44,563,45,SUBMITTED,no,"The mutant code is not buggy. The getAverageMillisPerYearDividedByTwo method in the mutant code returns MILLIS_PER_YEAR / 3, which is a valid operation and will not cause any exceptions or errors.  However, the buggy code is indeed buggy. The getAverageMillisPerYearDividedByTwo method in the buggy code attempts to divide MILLIS_PER_YEAR by zero, which will cause an ArithmeticException due to division by zero. This is a bug because it will cause the program to crash when this method is called. The original method should not have this behavior, so the change in the buggy code introduces a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
102,563,10,SUBMITTED,yes,"The original code divides MILLIS_PER_YEAR by 2, giving the average milliseconds for half a year. The mutant code divides MILLIS_PER_YEAR by 3, giving the average milliseconds for one-third of a year.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
106,565,2,SUBMITTED,yes,because one returns the negative of the year difference if the minuendInstant is less than the subtrahendInstant while the other does than when it is greater than or equal to,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
39,565,3,SUBMITTED,yes,the condition is reversed,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
80,570,2,SUBMITTED,yes,"The mutant code snippet shows a clear bug as it uses a multiplication instead of division operator, which makes the output different.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
59,570,2,SUBMITTED,yes,Multiplied with 2 != divided by 2,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
103,573,6,SUBMITTED,yes,The mutant is buggy because you subtract from one after the division which would be different than just dividing by two. With the change you would be dividing by two and then subtracting by one which would return different answers.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
19,573,2,SUBMITTED,yes,subtraction by 1 will result in a different output value,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
39,575,3,SUBMITTED,yes,Adding 353L instead of 352L will make difference in the final result,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
19,575,2,SUBMITTED,yes,return value of the function will be different because of the different added long value,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
103,580,6,SUBMITTED,yes,"The mutant is buggy because a change in one millisecond can change the date by a whole year Dec 23, 2023 can change by the addition of one millisecond that will result in Jan 1, 2024 which is a leap year which would return false, while if there wasn’t a millisecond added Dec 23, 2023 would return false.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
44,580,45,SUBMITTED,yes,"The buggy code is indeed buggy. The isLeap method in the buggy code will always return true, regardless of whether the current time is in a leap year or not. This is because of the || true part of the return statement, which means the method will return true even if getField().isLeap(getMillis()) is false. This is a significant change in behavior from the original (mutant) code, making the buggy code buggy. The original method should return whether the next millisecond is in a leap year, not always true. So, yes, the buggy code is really buggy. The mutant code is correct and does not have this issue. It correctly checks if the next millisecond is in a leap year.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
16,580,7,SUBMITTED,yes,We send different(incremented) parameter.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
19,586,2,SUBMITTED,no,"with the nature of boolean algebra, OR statement with a false will produce the same expression",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
38,586,1,SUBMITTED,no,"The mutant code just adds an or statement with boolean false. This does not change the outcome of the function due to boolean algebra laws. This not a bug,",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
102,587,10,SUBMITTED,yes,The mutated code does not give the same deterministic output as the original code. The reason is that the time zone ID is changed from the specific value returned by getID() to an empty string,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
59,587,2,SUBMITTED,yes,unusual offset is not same as an empty string,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
92,587,21,SUBMITTED,yes,"Using an empty string as the time zone ID may cause callers to be unable to recognize or handle the time zone, especially in scenarios where displaying time zone information or perforg time zone conversions is required.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
88,594,5,SUBMITTED,yes,"If evaluators list has only one element, we expect rightMostEvaluator to return that, but in mutated version the result wiil be null.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
83,594,9,SUBMITTED,yes,"In the original code, the function returns  evaluators.get(num - 1) when num is greater than 1, and null otherwise. In the buggy code, the function returns null when num is greater than zero, and num -1 otherwise. The only case where the functions would return the same thing is when num is equal to 1, and i think the implementation should cover all cases not just 1 case.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
16,594,7,SUBMITTED,yes,The difference lies in the condition num > 0 vs. num > 1.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
33,601,4,SUBMITTED,no,This is because the output of the two code snippets will remain the same since variable flag will always be 1.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
4,601,1,SUBMITTED,no,"The flag is initialzed with value 1, so it will always enter the first condition and return hasArg(true);",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
69,602,4,SUBMITTED,yes,Mutant would return true even if valuesep is 0,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
13,602,9,SUBMITTED,yes,"The mutant function will return true if valuesep is 0, while the original function will return false if it is 0.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
73,604,4,SUBMITTED,yes,"In the mutated snippet, the seed value for the hash function has been changed resulting in different programmatic behaviour from the original code. Therefore, it is a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
20,604,13,SUBMITTED,yes,"The hexadecimal number represents an integer, so passing it in the original code will give different output and in the mutant code subtracting 1 from it will pass a different value",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
2,604,6,SUBMITTED,yes,"The value of the seed changes after subtracting 1, resulting in different last eight digits, which in turn generates a different 'h', leading to a different final result.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
20,607,13,SUBMITTED,yes,"In Base32 constructor, the boolean parameter deteres  whether padding is enabled or disabled. In the original code it’s passed as false, while in the mutant code it's passed as true.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
91,607,7,SUBMITTED,yes,The original and mutant code have different behaviors because when Base32 object created and has a true input it means that it is using Base 32 Hex alphabet and when the input is false it uses a Base 32 alphabet. Hence their behaviors are different.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
54,610,6,SUBMITTED,yes,"The mutant code calls ""Objects.equals"" on ""orderingBits"" but doesn't return the result, so the result of this comparison isn't used as it should",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
5,610,18,SUBMITTED,yes,"The mutant code has changed the behavior of the equals method. In the original code, the method returns true if both orderingBits and comparatorChain of the current object and the other object are equal.  In the mutant code, it still checks the equality of orderingBits and comparatorChain, but it ignores the result of Objects.equals(orderingBits, chain.orderingBits). It only returns the result of Objects.equals(chain.comparatorChain, comparatorChain).  This change in behavior could lead to bugs, as the method no longer checks the equality of orderingBits when detering if two ComparatorChain objects are equal.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
65,610,12,SUBMITTED,yes,"""return Objects.equals(orderingBits, chain.orderingBits) &&                    Objects.equals(comparatorChain, chain.comparatorChain);"" this returns a boolean value and return Objects.equals(chain.comparatorChain, comparatorChain);"" doesn't returns any boolean value so this can produce a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
63,613,5,SUBMITTED,no,"Here, the loop iterator is counting backwards but the loop still runs for ""iCount"" number of times. Also, the statement inside the for-loop executes independent of the ""iCount"" variable so there is no change in the behavior of the code and the mutant is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
76,613,12,SUBMITTED,no,"The order in which the inputs are executed is different, but the order of execution doesn't mean the output will be different.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
28,615,5,SUBMITTED,yes,as when there is any exception occured instead back to call stack it will return false which can cause an altering to the normal behavior which is the opposite of the iPredicate,6/26/2024 3:46,6/26/2024 3:46,0,0,2,3,5,yes,0/2/3
7,615,15,SUBMITTED,yes,"The main code doesn't have try catch block whereas the mutant does have it. So, it behaves differently in different inputs.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,3,5,yes,0/2/3
41,615,7,SUBMITTED,no,"the try catch is used to check if there are errors, if no error, the output on both ends will be same.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,3,5,yes,0/2/3
91,615,7,SUBMITTED,yes,"The mutated code does not throw the exception but instead returns false, which is a different behavior compared to the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,3,5,yes,0/2/3
38,615,1,SUBMITTED,no,There does not seems to be a problem in the function since it just adds a try catch system in the code. It returns the negation of the evaluate function and if there is an error it returns a false boolean,6/26/2024 3:46,6/26/2024 3:46,0,0,2,3,5,yes,0/2/3
12,617,3,SUBMITTED,yes,it neglects the result of ipredicate1,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
101,617,6,SUBMITTED,yes,"Yes. While the original code checks to see if iPredicate1.evaluate(object) returns true on the first branch of the or operand, the mutant case checks if iPredicate1.evaluate(null) returns true. These are not necessarily equivalent as if they do not return the same output, they may return different outputs overall which may end up depending on their equivalent second branch of the or operand. How iPredicate1.evalute() behaves on null may lead to differences in output between the two functions.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
21,619,6,SUBMITTED,no,"In the main code a for loop is used; however, in the mutated code a while loop is used. They both are using the same logic. Starting with 0, until you reach the upperbound (i < iPredicates.length)",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
93,619,7,SUBMITTED,no,Mutant code contains equivalent version using while loop instead of for loop.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
96,623,2,SUBMITTED,yes,The logic of mutant version is wrong,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
88,623,5,SUBMITTED,yes,"Consider FilterListIterator with a predicate that is false for every member of iterator. In such case in original code the result of hasPrevious wil always be false, when in the mutated code it will be always true(because previousObjectSet will always be false, and setPreviousObject will be false because not previous can be set)",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
78,623,9,SUBMITTED,no,in both cases it is going to set previous object and return the value true,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
48,624,10,SUBMITTED,yes,"In the original code, 'this.lastItedex' is equal to 'this.index - 1', and the function later returns an element of a list with index 'this.index'. While in the mutant code 'this.lastItedex' is equal to 'this.index' and 1 is subtracted from 'this.index'. Therefore in the mutant code, the returned value is 'this.array[this.index - 1]' which is different from what the original code returns. The mutant is thus buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
45,624,30,SUBMITTED,yes,"Even though both versions return the previous element correctly, there is a difference in how the lastItedex is assigned.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
88,626,5,SUBMITTED,no,"The main side-effect is done when hasNext is false and inner if-s are ok, in both the main and mutant version.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
10,626,8,SUBMITTED,no,Both the original and the mutant produce same outcomes for all the cases. In both the code we execute the logic to find the next value when field 'hasNext' is false and return when 'hasNext' is true.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
43,626,4,SUBMITTED,yes,"The mutated code always updates the root, but this should only be done when the currentIterator is null.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
22,632,4,SUBMITTED,yes,"We are replacing validating the object with validating null, which will definitely change the intended behavior depending on the predicate. If the predicate was to prevent null values, then the add function will always fail.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
24,632,3,SUBMITTED,yes,RHS code misuses the validate method by passing null as an argument,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
54,642,6,SUBMITTED,yes,"The mutant is buggy as it always returns true, while our condition clearly states that its true only if the ""valuePredicate"" is in use (not null)",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
56,642,4,SUBMITTED,yes,updated mutant always returns true no matter what. However the original code returns true only if valuePredicate is not null.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
17,644,30,SUBMITTED,no,The variable declaration is redundant and does not change the output of the function,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
68,644,18,SUBMITTED,no,the code is fine it will not cause any issue,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
102,645,10,SUBMITTED,yes,"The mutated code does not give the same deterministic output as the original code. The reason is that the original code can throw a NoSuchElementException if iterator.next() is called without checking iterator.hasNext(). The mutated code adds this check and returns null if there are no more elements, altering the behavior and output of the method in scenarios where the iterator has no next element.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
77,645,3,SUBMITTED,no,"The mutant is is safer and more robust because it checks if there is a next element before attempting to retrieve it,",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
51,645,15,SUBMITTED,yes,"The second implementation handles the case when there are no more elements in the iterator by explicitly checking if there exist a next element using hasNext(), then returning the next element in the stream assug  and otherwise returning null, while the first assumes that there is always a next elements and does not provide any explicit handling for the case when there are no elements. So it will result in an exception being thrown( NoSuchElementException) .",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
1,649,2,SUBMITTED,no,"The size will never get under the 0  based on existing code, so, the behavior is always the same for n=0",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
87,649,9,SUBMITTED,no,"because the size() function in java returns the size of a collection, or list and these can never be negative which does not affect the code in any way.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
53,651,13,SUBMITTED,no,"The do in the second code snippet (Mutated code) causes the count (decorated().getCount(object)) to be gotten at least once. Since the object count cannot be negative, the while statement is never run, which implies count assigned once. The value of count is then returned",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
30,651,10,SUBMITTED,no,"Though the mutated code adds a do-while loop, it still only executes once because getCount(Object object) always returns a non-negative value according to Bag.java code and functions the same as the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
39,653,3,SUBMITTED,yes,"Although I did not find the implementation of validate() function, it takes object as an argument, and the modified code checks for the ""count"". They are validating different arguments.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
19,653,2,SUBMITTED,yes,A restriction of 100 copies is added in the mutant altering its behavior from  the original,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
75,654,21,SUBMITTED,no,"First, tailMap(fromKey) operation generates a view of the normalMap, containing all entries with keys greater than or equal to fromKey. The result is a sorted map (sub) that begins at fromKey. Then, headMap(toKey) operation creates a refined view that includes only the entries with keys less than toKey on the sorted map obtaind from the tailMap(fromKey) call. This effectively narrows down the map to include entries in the range starting from fromKey and ending just before toKey. Lastly, the resulting submap is then wrapped in an instance of ViewMap. These steps result in a code snippet which has the same behaviour with the original implementation.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
28,654,5,SUBMITTED,no,as the fail map getting the whole map til the tokey and then the headmap getting the array starting from from key till the end of the map,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
14,654,4,SUBMITTED,no,"Perfroms the same task but in two steps. At first it takes sub map for keys after from key, then takes keys upto two key, which is same as original code",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
77,655,3,SUBMITTED,yes,The issue lies in the order of operations and the logic used to update compressedCount.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
18,655,3,SUBMITTED,yes,"So it adds a subtraction before the fill method, and remaining can be more than zero before the fill, therefore it affects the value of compressedCount.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
91,656,7,SUBMITTED,yes,"The mutated code it doesn't return value r, but instead returns 0, which means regardless of the input it would return the same thing.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
77,656,3,SUBMITTED,yes,It always returns 0 regardless of the value read from the input stream.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
53,656,13,SUBMITTED,yes,The second code snippet (mutant) always returns 0 irrespective of the value of r. r is not guaranteed to always be 0.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
2,656,6,SUBMITTED,yes,It is possible that r is not 0.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
40,657,4,SUBMITTED,no,"Mutated code can also serve the same purpose, the mutated code excludes the case when seconds is equal to Integer._VALUE (which is  -2,147,483,648), which is highly unlikely and generally not practical for seconds to be equal to Integer._VALUE. Reason is that the Unix Epoch (January 1, 1970) is used as a reference point, and the representation of time in seconds is typically positive!. The equaltiy condition might not have a meaningful interpretation in the context of Unix time or real-world systems ( More of a theortical consideration than something commonly encountered in practical use cases).",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
11,657,2,SUBMITTED,no,The Integer._VALUE and Integer.MAX_VALUE cannot be reached by integers so the == operation will always be false so when removing the == from ≤ the output wont change,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
97,658,2,SUBMITTED,no,"Integer.MIN_VALUE <= seconds and seconds >= Integer.MIN_VALUE, both are the same statements. They both return true if Integer.MIN_VALUE is less than or equal to seconds",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
73,658,4,SUBMITTED,no,Both the original  and mutated snippet method will return True if  the value of input parameter seconds lie between the imum and maximum Integers.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
71,658,4,SUBMITTED,no,here we changed just  the  operator  with the value which is the result will be the same.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
86,660,6,SUBMITTED,no,"In fact, mutated code is more correct than the original!",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
53,660,13,SUBMITTED,yes,"In the case where the readIndex is greater than the writeIndex, the first code snippet would return True while the second code snippet (Mutant) would return False",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
4,660,1,SUBMITTED,yes,"The first function return True if (readIndex > writeIndex or readIndex < writeIndex), while the second function returns True only if readIndex < writeIndex",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
58,668,9,SUBMITTED,yes,"The original code has the return condition as true if compare is greater than 0, otherwise false. The mutant code has the return condition as true if compare is less than or equal to 0, otherwise false. This is a bug as it changes the whole logic of the code. It inverts the logic, returning true where it should be false and vice versa thereby changing the behavior of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
80,668,2,SUBMITTED,yes,"This is a clear bug because mutant version replaces the original comparison operator with its exactly the opposite one. An accurate result of True boolean decision would turn out to be False in the modified code snippet, for example.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
59,670,2,SUBMITTED,yes,i>0' is not same as 'i>=0'. No execution for the former.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
61,670,4,SUBMITTED,yes,"Second code appends one more "","" then first.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
104,670,5,SUBMITTED,yes,extra append at beginning of buffer,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
101,677,6,SUBMITTED,no,"No. Utilizing the ternary operator, the mutant version correctly writes the equivalent utilizing if branches",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
8,677,6,SUBMITTED,no,Both original and mutant code are functionally equivalent. The only difference is the way the conditional expression is written. The original code uses Ternary Operator ( ? : ) whereas in mutant code uses if-else. This is just a stylistic change and does have side effect.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
89,677,19,SUBMITTED,no,Both the code snippets are equivalent. The only difference is that the left one is implemented using conditional operator and the right is implemented using if else statements.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
22,681,4,SUBMITTED,no,"getNamespaceURI(prefix) on parent returns null no matter what prefix is, so the function will still return null anyway even if we remove the check for prefix to be null (in the original code, both branches of the if statement lead to a null value).",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
18,681,3,SUBMITTED,no,"Since getNamespaceURI already returns null when the given value is null, both performs the same action.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
43,686,4,SUBMITTED,yes,"The original code returns super.isUseClassName(), but the mutated code returns the complement of it, so the return values are always opposite.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
62,686,6,SUBMITTED,yes,The mutant deviates from the corrected and buggy codes by always returning true. This introduces a bug because it ignores the logic implemented in the superclass and forces class name usage regardless of the intended behavior.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
69,686,4,SUBMITTED,yes,Mutant return true directly while in the original code we check in the super class ToStringStyle for isUseClassName,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
85,687,2,SUBMITTED,no,both versions of the code will convert the character representation of a digit to its corresponding integer,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
2,687,6,SUBMITTED,no,The Ascii for '0' is 48.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
100,692,3,SUBMITTED,no,Disjunction with false is an identity operation.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
94,692,30,SUBMITTED,no,The correct and mutant code are functionally identical. ORing the boolean variable 'super.isFieldSeparatorAtStart()' with 'false' will always return the value of 'super.isFieldSeparatorAtStart()' itself.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
20,693,13,SUBMITTED,no,Having double not equal signs in the mutant code will give the same result as the original code,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
92,693,21,SUBMITTED,no,"The mutated method uses a logical negation of the condition that the comparison result is not equal to 0, which logically is the same as checking if the comparison result is equal to 0. Therefore, the mutation does not change the behavior or the output of the equalTo method",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
104,693,5,SUBMITTED,no,two not's equivilent to original,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
40,695,4,SUBMITTED,no,"The mutated code will produce same output as the original code. The reversed conditions in the mutated code do not alter the behavior, and the output will remain the same for both the original and mutated code. The conditions essentially check if ch is within the bounds of the array, and the order of the conditions does not affect the logic.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
89,695,19,SUBMITTED,no,Only the arrangement of the conditions and use of 'if' block is different otherwise the code is same. Both the codes will return the same value when a) ch is less than CHAR_STRING_ARRAY.length b) when ch >= CHAR_STRING_ARRAY.length.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
99,696,6,SUBMITTED,no,"There is extra safeguard condition for ch<0 in which case behaviour of program would have changed but in java char data type is 16 bit unsigned integer, hence it cannot be possible for ch to take negative values. hence the behaviour of program will not change.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
98,696,4,SUBMITTED,no,"The char value will never be negative, and seeing how the if statement on the right side evaluates the negation of the left side and swaps what the program returns, the left and right side are semantically equivalent.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
7,696,15,SUBMITTED,no,"Both code produces the same result. Only the checking condition is changed, no bugs are introduced.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
62,696,6,SUBMITTED,no,The mutant improves the conditional logic to cover edge cases with negative ch values and the scenario where ch equals the array length.,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
16,701,7,SUBMITTED,yes,"It will not change behaviour of the return function. However, lastCallsPerPeriod changes after return.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
29,701,2,SUBMITTED,yes,"Mutant code changes the intended behavior of the original code. Simple getter is extended with side effect (incrementing the value of ""lastCallsPerPeriod"").",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
5,702,18,SUBMITTED,yes,"The mutant code is missing the custom error message for resourceName. In the original code, if resourceName is null, it throws a NullPointerException with the message ""resourceName."" In the mutant code, it will still throw a NullPointerException, but without a specific message.  This could be considered a or bug, as the functionality still needs to be changed (a NullPointerException is still thrown when resourceName is null), but the error message needs to be more informative.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
100,702,3,SUBMITTED,no,Both the arguments are independent so the order doesn't matter.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
71,702,4,SUBMITTED,yes,there is bug in this line of code and we tried to throw the exception. .,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
95,711,68,SUBMITTED,yes,Added code not working,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
83,711,9,SUBMITTED,yes,The original code casts ‘value’ to be of type ‘float’ while the buggy code just adds 1. They are not doing the same thing.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
35,717,6,SUBMITTED,no,Both of the codes execution renders the same result.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
29,717,2,SUBMITTED,no,"The only difference between original and mutated code is the question of readability. If mutated code contained prefix decrement operator (as opposed to postfix decrement operator), a bug would be introduced because the value of variable ""value"" would firstly be decremented and then copied to the variable ""last"".",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
14,719,4,SUBMITTED,yes,Typecasting to int from long reduces range,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
19,719,2,SUBMITTED,yes,"If the value is small type casting wont have an effect, however if the values are large then some bits will be lost and cause erroneous values to be stored in the long variable",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
28,721,5,SUBMITTED,yes,as it returns an empty object's toString() instead of value (stated already in the comment),6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
7,721,15,SUBMITTED,yes,Both code provides different outputs. Main one provides string representation of the object whereas the mutant provides string represent of a new Object class instance.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
44,731,45,SUBMITTED,yes,"The buggy code is indeed buggy. In the original (mutant) code, the formatUTC method formats a date (created from millis) using a specified pattern and UTC_TIME_ZONE. The locale is not used in this method.  In the buggy code, the formatUTC method attempts to format a date (created from millis) using null as the pattern, which will likely cause an exception or error because a null pattern is typically not allowed in date formatting methods. The locale is passed to the format method, but it’s unclear how it’s used without the context of the format method’s implementation. This is a significant change in behavior from the original code, making the buggy code buggy. The original method should format the date using the specified pattern, not null. So, yes, the buggy code is really buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
53,731,13,SUBMITTED,yes,"While null is an acceptable value for the variable 'locale', changing the code to fix the value of 'locale' as null would mean a wrong result would be returned for cases where the value of 'locale' passed into the method is not null.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
105,732,0,SUBMITTED,yes,"The mutant removes the null check for the calendar object. This will cause a NullPointerException if calendar is null, whereas the original code safely returns null in such cases.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
1,732,2,SUBMITTED,yes,"if calendar is null, return an exception",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
106,733,2,SUBMITTED,no,"the original code and the mutant code are the same exact statements but the mutant has a comment that says buggy code, but it doesn't change/ diverse the functionality of the the 2 codes",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
39,733,3,SUBMITTED,no,I do not see any difference in the two blocks of code.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
99,733,6,SUBMITTED,no,"Both the code snippets are same, except for the commented line, hence it wont change the program output/behaviour.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
70,734,9,SUBMITTED,yes,"The original code checks for content equality, while the second snippet checks for reference equality therefore it will give a different output.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
62,734,6,SUBMITTED,yes,The mutant introduces a bug by using reference equality (==) instead of a proper equals method.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
75,736,21,SUBMITTED,no,It is not buggy since both implementations will produce the same outcome.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
67,736,15,SUBMITTED,no,The effect of these codes are the same but they are represented differently.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
74,738,2,SUBMITTED,yes,Will change the return value of the code,6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
83,738,9,SUBMITTED,yes,"the buggy implementation creates an array of Object objects and performs an unsafe cast, potentially leading to ClassCastException errors at runtime.",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
82,738,2,SUBMITTED,maybe,It depends on what EMPTY_ARRAY does. The mutant code creates a five length empty array.,6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
60,739,8,SUBMITTED,maybe,"This depends on the type of variables being passed to the map, so it potentially could be buggy.",6/26/2024 3:46,6/26/2024 3:46,0,2,0,0,2,maybe,2/0/0
42,739,15,SUBMITTED,maybe,Pair[0] is dynamically allocating an empty array which could encounter unchecked warnings,6/26/2024 3:46,6/26/2024 3:46,0,2,0,0,2,maybe,2/0/0
96,740,2,SUBMITTED,no,The output is the same,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
57,740,5,SUBMITTED,no,"The mutant returns new Triple[0] instead of returning EMPTY_ARRAY, which is a constant initialized to an empty array of Triples.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
11,744,2,SUBMITTED,yes,The mutated code set the bits starting from 0 till the toIndex value while the original code set the bits starting from the given index which is frodex,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
96,744,2,SUBMITTED,yes,The fromIndex is always 0 in this case,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
50,745,8,SUBMITTED,no,Both the original and mutant return true when natural ordering is used,6/26/2024 3:46,6/26/2024 3:46,0,3,1,0,4,maybe,3/1/2000
58,745,9,SUBMITTED,maybe,"The change from comparing a comparator to ComparableComparator.INSTANCE to using Comparator.naturalOrder() in the mutant code is ambiguous, as it depends on whether both references are intended to be equivalent. If ComparableComparator.INSTANCE and Comparator.naturalOrder() are intended to be the same, the mutant would report the natural ordering status incorrectly. So to know whether or not the mutant is buggy we need to know the relationship between ComparableComparator.INSTANCE and the comparator returned by Comparator.naturalOrder().",6/26/2024 3:46,6/26/2024 3:46,0,3,1,0,4,maybe,3/1/2000
1,745,2,SUBMITTED,maybe,"If the items in the collection are not in the natural order, might return different results.",6/26/2024 3:46,6/26/2024 3:46,0,3,1,0,4,maybe,3/1/2000
92,745,21,SUBMITTED,maybe,"The correct code is comparing using an existing comparator, whereas the Mutant code is creating a new natural order comparator for comparison. This may introduce a bug because the objects being compared have changed.",6/26/2024 3:46,6/26/2024 3:46,0,3,1,0,4,maybe,3/1/2000
56,748,4,SUBMITTED,no,"stringUtils.EMPTY is same as """" as long as it is not initiated as final.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
100,748,3,SUBMITTED,no,"StringUtils.EMPTY is set to """" and is final.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
44,748,45,SUBMITTED,yes,"The buggy code is indeed buggy. In the original (mutant) code, the removeFirst method replaces the first match of the regex pattern in text with an empty string.  In the buggy code, the removeFirst method attempts to replace the first occurrence of an empty string in text with regex. This is a significant change in behavior from the original code, making the buggy code buggy. The original method should replace the first match of regex with an empty string, not replace an empty string with regex. So, yes, the buggy code is really buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
3,750,5,SUBMITTED,yes,"within the getProperty method, System.getProperty() is invoked, so returning just the PATH_SEPERATOR constant will likely result in bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
9,750,9,SUBMITTED,yes,null will not be a parameter,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
42,756,15,SUBMITTED,no,it is the same,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
7,756,15,SUBMITTED,no,Only the formatting is changed i.e. spacing or line breaks are removed. So it doesn't give significant code bugs.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
48,757,10,SUBMITTED,,"In the original code, 'this.elitismRate' is equal to 'elitismRate' and in the mutant code it is equal to 'this.elitismRate + elitismRate'. Therefore the mutant is buggy.",6/26/2024 3:46,6/26/2024 3:46,1,0,0,4,4,yes,0/0/4
83,757,9,SUBMITTED,yes,the original code adds the new elitismRate value to the current existing value while the buggy implementation assigns the 1 - elitismRate to the current value. They will have completely different results.,6/26/2024 3:46,6/26/2024 3:46,1,0,0,4,4,yes,0/0/4
93,757,7,SUBMITTED,yes,Replacing the assignment operator with compound assignment operator changes the output of the mutant code.,6/26/2024 3:46,6/26/2024 3:46,1,0,0,4,4,yes,0/0/4
14,757,4,SUBMITTED,yes,"+= and = are not equivalent expression.The first one adds with the original value and assigns it, and the later one just assigns the value",6/26/2024 3:46,6/26/2024 3:46,1,0,0,4,4,yes,0/0/4
3,757,5,SUBMITTED,yes,"Instead of assigning to elitismRate, the modified code is instead adding to elitismRate. This will cause the method to behave differently.",6/26/2024 3:46,6/26/2024 3:46,1,0,0,4,4,yes,0/0/4
91,759,7,SUBMITTED,yes,The mutated code adding 1 to the same code original code changes the meaning of the function because if the two doubles are equal it should return 0 but in the mutated code it returns 1.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
4,759,1,SUBMITTED,yes,The function return the same answer but increases it by 1 which for sure is a mutant,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
89,759,19,SUBMITTED,yes,"Adding 1 will change the output of the comparison. -1, 0, 1 will become 0, 1, 2 respectively. This is not the required output according to the conditions provided in the comments from line 50 to line 58 and in the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
52,763,36,SUBMITTED,yes,"The indentation in Java is not sensitive so it will not represent a problem, but the change which is NullPointerException when secondaryState is null, where in the original code would return 0",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
105,763,0,SUBMITTED,yes,"The mutant introduces a bug by reversing the logic of the ternary operator. This causes a NullPointerException when secondaryState is null, which is a significant behavioral change from the original code that handles null correctly.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
13,766,9,SUBMITTED,yes,"Multiplication and addition is not interchangable, the mutant code will return a different value than the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
52,766,36,SUBMITTED,yes,"The changing in the order of addition and multiplication operations will provide two different hash codes and this is considered as an output error and according to the definition of buggy code provided in the document file you provided it is a buggy code, but there will no be any errors in the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
35,770,6,SUBMITTED,yes,"biasCorrected can either be true or false in the original code but, in the mutated code it must be false.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
31,770,15,SUBMITTED,yes,"In the mutant code, from now on, the function initializeMatrix will always be called with a false boolean parameter, since everything ANDed with false is false. However, in the original code, the parameter depends on the value biasCorrected, which can be either true or false. Therefore, the mutant code changes the code’s output and behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
94,770,30,SUBMITTED,yes,The boolean condition of the initializeMatrix() statement will always be set to false regardless of the value of 'biasCorrected',6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
31,773,15,SUBMITTED,yes,"According to the code, _NEURONS is a final integer equal to 2. Obviously, if (num < 2) in the original code, and if (num < 1) in the mutant code are different since they give different results when num is 1. So, the mutant code changes the code’s output and behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
19,773,2,SUBMITTED,yes,Value is being compared to a smaller value than the orignal,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
45,776,30,SUBMITTED,no,"There is no difference between these two code versions since both give the same outcomes even though how they check the equality. Note that, equals(Object) and hashCode(Object) methods should be overridden.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
99,776,6,SUBMITTED,no,The mutated version does not change the behavior for valid inputs. It adds a safeguard that is not strictly necessary but does not harm the functionality.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
27,780,3,SUBMITTED,yes,"The mutant code is buggy because it changes the behavior of the constructor to use the root causes message “(rootCause.getMessage())” instead of the provided “msg”.This alteration can lead to loss of the original error message intended by the caller, potentially obscuring the context or specificity of the exception, which is crucial for debugging and understanding the errors of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
93,780,7,SUBMITTED,yes,The mutant is buggy because it changes the exception message and introduces a potential NullPointerException by using rootCause.getMessage() instead of the intended msg parameter.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
90,781,5,SUBMITTED,no,"The edited code adds redundant operations but does not change the behavior or output compared to the original code, so it does not introduce a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
63,781,5,SUBMITTED,no,"The mutant is not a bug because the mutant code performs the same task as the original code, which is to extract the least significant 8 bits from the value obtained from the input buffer. The mutant just additionally retains the least significant 24 bits of the value obtained from the input buffer, before applying another mask to retain the least significant 8 bits.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
24,783,3,SUBMITTED,no,RHS code is not buggy and functions identically to the LHS code in terms of the parseVersionPart method. The use of >= instead of > does not affect the outcome,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
71,783,4,SUBMITTED,no,logical operator changed but still the same logic.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
52,788,36,SUBMITTED,yes,"The code on the left side sets the feature mask based on the result of f.mappedFeature().getMask, the code on the right side used a NULL check and only sets the feature mask if f.mappedFeature() is not NULL which means it prevents the NullpointerException if f.mappedFeature() is null, also on the right side there is an increment by 1 and it will change the feature set which means it may introduce new feature or set an existing one.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
19,788,2,SUBMITTED,yes,output of the bit wise OR will be different after the addition of 1 to the featuremap,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
101,801,6,SUBMITTED,no,"No. The order in which variable _referringProperties is set to null, whether before or after the while loop, doesn’t change the flow of the function nor the output. Therefore, both versions are equivalent",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
68,801,18,SUBMITTED,no,will not affect the flow of the code so the change does not make the code buggy,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
73,801,4,SUBMITTED,no,"Once iterator of the _referringProperties is set , it does not matter when the _referringProperties is set to null before or after linkedlist traversal",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
29,802,2,SUBMITTED,yes,"Without inspecting the innerworkings of ""FactoryBasedEnumDeserializer"" I can only assume that passing null (mutated code) each iteration of the for loop instead of provided ""DeserializationContext cntx"" (original code) to the ""_deserializeWithErrorWrapping()"" introduces a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
103,802,6,SUBMITTED,yes,The mutant is buggy because ctxt is not always going to be null when you assignparameter to buffer.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
60,806,8,SUBMITTED,yes,Will fail when the index is even.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
13,806,9,SUBMITTED,yes,"This may result in unexpecte results as the variable t is set to null if the index is an even number otherwise if index is an odd number it follows the same code as the original. This will not result in a bug, jus unexpected results.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
32,807,20,SUBMITTED,yes,"In the mutated case, the return condition from the original case has changed, the function thus will only return true if and only if _typeHandler is not equal to null and _valueHandler is equal to null.  Thus, condition of output has changed altering the behaviour of the code and causing a bug.",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
24,807,3,SUBMITTED,maybe,"LHS code (||) returns true if at least one handler is not null, while the RHS code (&&) returns true only if the _typeHandler is not null and the _valueHandler is null.",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
76,807,12,SUBMITTED,yes,"The original code returns true when either one of them is true, but the mutated version returns true only if both conditions are true, however it doesn't take into account for the condition when _valueHandler!=null",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
24,811,3,SUBMITTED,yes,"It is a bug, as it will consider only negative values( as assignment operator is changed from <= to =)",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
103,811,6,SUBMITTED,yes,"The mutant is buggy because when _value.scale is 0 it is going to return true since 0<=0 while on the right it is going to return false 0 < 0. No matter what the other statements are on the left since 0<=0 evaluates to True the left is always going to be true, while the right isn’t guaranteed to be true since that statement is now false",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
30,811,10,SUBMITTED,yes,"canConvertToExactIntegral() should return true when the _value (1) is zero OR (2) represents an integer OR (3) has trailing zeros to the right of the decimal point (ignoring those zeros). While in mutated code, for example when the _value is 123, the method will return false.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
78,811,9,SUBMITTED,yes,in the mutant logic is changed so it will return different result,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
63,813,5,SUBMITTED,no,"This mutant is not a bug and the code has the same functionality as that of the original code. Both the conditions in the return statements are equivalent because the use of logical AND in the mutant, between two exactly same conditions produces the same output as that of the condition (_value != 0) alone.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
67,813,15,SUBMITTED,no,"I couldnt find any differences just the repetition of the same expression, && in between.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
79,816,2,SUBMITTED,yes,"We know both Double and Integer classes in Java inherit from the Number class. If _value is a Double type but not Integer(e.g: 2.34), then in case of mutant version, (_value instanceof Integer) condition will return false and asDouble() will return defaultValue. But in the original code, (_value instanceof Number) will still return true and asDouble() will return ((Number) _value).doubleValue(). Therefore, here the mutant is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
51,816,15,SUBMITTED,yes,"beacause there exist a Number field which is not covered by the 32-bit Integer. So for those values the mutated code will always return the default value, where as in the correct code the if block will be executed and a new double value is returned",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
15,817,4,SUBMITTED,yes,"If value was a float for example the mutant will not extract the int value from value, while in the original, it extracts the int value from any number type",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
22,817,4,SUBMITTED,yes,"The method would no longer allow other types of _value which inherit from Number (such as shorts, longs, BigInteger, and other) to return an asInt() integer value and restricts it solely to the Integer type instead. This would not be an issue if _value is only expected to be an integer, but further digging into the uses of the POJONode class shows that it could be virtually anything.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
73,817,4,SUBMITTED,yes,"The mutant method returns _value only if _value is of Integer type. However in the original code, if _value of class Number (which not only includes Integer but also Double,Long , etc) then it is returned.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
103,818,6,SUBMITTED,no,The mutant is not buggy because long refers to integer numbers and should be returning the same number,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
5,818,18,SUBMITTED,no,"The mutant code has added an additional null check and a specific check for the Integer type.  In the original code, if _value is an instance of Number, it directly casts _value to Number and returns its long value. If _value is not a Number, it returns the defaultValue.  In the mutant code, it first checks if _value is not null and an instance of Number. If _value is an instance of Integer, it casts _value to Integer and then to long. If _value is not an Integer or is null, it returns the defaultValue.  The additional null check in the mutant code prevents a potential NullPointerException if _value is null. The specific check for the Integer type is not necessary because an Integer is a Number, and calling longValue() on an Integer object will return the correct long value.  Therefore, the mutant code is not buggy, but the additional check for the Integer type is unnecessary. The null check could be considered an improvement if _value could potentially be null.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
105,818,0,SUBMITTED,yes,"The procedure is made more complex by the mutant, who adds an extra type check and casts for integers. If the value is a number, the original code translates it appropriately and is easier. The mutant can be regarded as a bug since it adds needless complexity without enhancing functionality. It should also always control and return values of the long type, preventing any losses from casting to int. Therefore, the long type must be returned by asLong. To put it another way, casting as an int can result in damage, but it should always be managed by the long type and not the integrator.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
70,819,9,SUBMITTED,yes,"The first code snippet checks if _value is an instance of Number, which includes subclasses like Integer, Long, Double, etc. Considering that the related buggy code provided to us mentions Double, the mutant code can also be buggy as it mentions Integer.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
11,819,2,SUBMITTED,yes,"Number is more generic and covers all numeric types, including both floating-point and integer types, Double and Integer are specific classes representing certain types within the numeric hierarchy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
49,822,10,SUBMITTED,no,They are logically equivalent code snippets as the value of bits will only be incremented after the operation is performed as bits++ will only increment value after operation (in the mutant code).,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
66,822,14,SUBMITTED,yes,"in  mutated code bits value is post  increment after  it  used for indexing the HEX_CHARS array.it affects the bits variable in appenshort may result in an incorrect representation of string as it may cayuse incorrect hexadecimal string generation,.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
88,822,5,SUBMITTED,no,"when ++ is after operand, the change will happen after the expression in evaluated. So the original and mutated are the same.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
75,825,21,SUBMITTED,yes,"If the shape is string, mutated code sets asBinary = true, which contradicts the original behavior. The original behavior would serialize the UUID as a string. But in mutant version, it would attempt to serialize it in a binary format, ignoring the explicit request for string serialization.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
6,825,11,SUBMITTED,yes,asBinary has a part where it is is false in the first code but in the mutated code it is true everywhere,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
64,828,8,SUBMITTED,no,"It’s not a bug, since we are just introducing a new variable that is not being used in the original function",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
14,828,4,SUBMITTED,no,getting a value from map doesn't modifies the map.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
31,831,15,SUBMITTED,maybe,"In this question, I couldn’t understand how much I am supposed to think in-depth, but I’ll give my opinion about that. For example, if our memory is very limited, and there is only space for INITIAL_CHUNK_SIZE many T’s, then trying to allocate INITIAL_CHUNK_SIZE+1many T's would result in OutOfMemoryError, whereas allocating INITIAL_CHUNK_SIZE many T's just fine. Also if we consider this class’s name being PrimitiveArrayBuilder, we don’t expect large objects of type T, so it might happen due to lacking available memory. Hence, the mutant code might change the code’s output and behavior. However, I couldn’t detere confidently the available memory size at the allocation time, due to GC, etc… That’s why wanted to decide on Maybe.",6/26/2024 3:46,6/26/2024 3:46,0,2,1,0,3,maybe,2/1/2000
65,831,12,SUBMITTED,no,"We were doing total opposite in the buggy code but in the mutant code we are just increasing chunk size + 1 instead of chunk size, so I don't think that is a major problem.",6/26/2024 3:46,6/26/2024 3:46,0,2,1,0,3,maybe,2/1/2000
5,831,18,SUBMITTED,maybe,"The mutant code has changed the behavior of the resetAndStart method. In the original code, if _freeBuffer is null, the method constructs an array with size INITIAL_CHUNK_SIZE. In the mutant code, it constructs an array with size INITIAL_CHUNK_SIZE + 1.  This change in behavior could lead to unexpected results if the code calling resetAndStart is not expecting to receive an array of size INITIAL_CHUNK_SIZE + 1 when _freeBuffer is null.",6/26/2024 3:46,6/26/2024 3:46,0,2,1,0,3,maybe,2/1/2000
97,832,2,SUBMITTED,yes,"The correct one returns ""[ ]""  and the second one returns a list of null. Returning null is not optimal",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
46,832,2,SUBMITTED,no,"In the original code, Collections.emptyList() returns an empty, immutable list. In the mutant code, Arrays.asList(new JsonNode[]{null}) also returns a fixed size (here, size 0) immutable list. Both codes give the same result. Hence the mutant code is not buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
25,832,2,SUBMITTED,yes,"The original code creates a list of size 0, thus containing no elements but the mutated one creates an arraylist of size 1 containing null, therefore, both don't exhibit the same behavior",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
16,832,7,SUBMITTED,yes,"The change in the mutated version introduces a bug because it modifies the behavior of the method. Instead of returning an empty list when findParents(fieldName, null) returns null, it now returns a list containing a single null element.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,3,4,yes,0/1/3
11,834,2,SUBMITTED,yes,Always set the variable _cfgDefaultUseWrapper false.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
39,834,3,SUBMITTED,yes,"If the function's logic requires 'b' to consistently be false, but we lack any prior knowledge regarding its value. so if b comes true, the logic will be wrong.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
88,834,5,SUBMITTED,yes,"The class is a group of utility functions for working with anotated java objects. As an example of bug, in case of deserializing an object with a member that has List type and no annotation, the original code uses default wrapper and output differs from mutant.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
72,845,5,SUBMITTED,yes,"The correct code returns the order of a polynomial which is not restricted to being 1 in the original program, but the mutant only returns 1.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
64,845,8,SUBMITTED,yes,"Yes, it is a bug since you are returning 1 instead of return this.coefficients.length – 1",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
102,845,10,SUBMITTED,yes,"The mutated code does not give the same deterministic output as the original code. The reason is that the original code correctly calculates the polynomial's order based on the length of the coefficients array, while the mutated code returns a fixed value of 1, which is incorrect for polynomials of any degree other than 1.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
100,845,3,SUBMITTED,yes,Clearly functionally inequivalent. Order need not always be 1.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
50,848,8,SUBMITTED,yes,"The super.clone() in the original code creates a shallow copy of the object, while the new Object() in the mutant will create a new Object instance that doesn't have same state as the original object",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
30,848,10,SUBMITTED,yes,"The mutated code will return an instance of Object, if we try to use this returned object as a SimpleHistogramDataset, it may lead to runtime issues, such as ClassCastException, because it’s trying to cast an instance of Object to SimpleHistogramDataset.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
90,850,5,SUBMITTED,no,"The change introduces a conditional check that does not alter the behavior of the method. The method setIntervalPositionFactor always calls this.intervalDelegate.setIntervalPositionFactor(d); regardless of the value of d. The conditional branches for d == 0 and else both execute the same line of code. Therefore, this modification does not affect the functionality of the original code in a meaningful way.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
50,850,8,SUBMITTED,no,"While there is if statement check in the mutant, it's setting the Interval with same value of d in both block, just like in the original code",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
87,851,9,SUBMITTED,yes,Because  the output of offset will vary in the buggy code but will always return 0 in the original code,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
45,851,30,SUBMITTED,yes,"The original code always returns 0; however, in the mutant code, there is a for loop that equals the return value to the parameter value.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
46,854,2,SUBMITTED,yes,"In the mutant code the greater-than-or-equal-to is added. So, when 'other' is null, and if getValue() is 0, then true is returned. But in the original code, false is returned. Hence the mutant code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
26,854,8,SUBMITTED,yes,"Since null means zero, if 'this' and 'other' are both zero, isGreaterThan returns true by mistake.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
36,855,4,SUBMITTED,no,Both return the milliseconds since the Unix epoch,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
79,855,2,SUBMITTED,no,"In the original code, the DateTimeUtils library is used and DateTimeUtils.currentTimeMillis() returns the current time in milliseconds. In the mutant version, DateTime.now().getMillis() also gets the current time in milliseconds. Therefore, in both cases, the behaviour will be the same and hence the mutant is not buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
102,855,10,SUBMITTED,no,The mutated code gives the same deterministic output as the original code because both methods are designed to return the current time in milliseconds. The change from using DateTimeUtils.currentTimeMillis() to DateTime.now().getMillis() should not affect the output,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
27,864,3,SUBMITTED,yes,"The mutant code is buggy because it passes “null” for the time zone instead of the system's default time zone. This change could lead to the “EthiopicChronology” instance not being configured correctly, affecting how dates and times are processed.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
33,864,4,SUBMITTED,no,"In the mutant snippet, instead of passing default time zone, null is passed, but, though it looks like a bug, it is not because in the larger code snippet, the null value is handled and set to default time zone.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
47,864,6,SUBMITTED,yes,Null is hard-coded and will always be passed instead of default time zone,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
80,868,2,SUBMITTED,yes,The mutant version uses “null” instead of “DateTimeZone.getDefault()” from the original code. The default value should be UTC as specified by the documentation. Returning a null would result in a bug.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
41,868,7,SUBMITTED,yes,"the getInstance method receives default time zone and 4 to the left, while to the right, it receives NULL and 4, the evaluation on both ends will result in different output.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
28,869,5,SUBMITTED,no,"As `getPartialValues(fieldSource, object, chrono);` will return `chrono.get(fieldSource, instant)` which will also return`int[] values = new int[size];` will return values after processing it",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
61,869,4,SUBMITTED,no,"atatype of partialValues and getPartialValues(fieldSource, object, chrono) is same",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
68,869,18,SUBMITTED,yes,not possible to declare variable like this so it is a bug,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
15,871,4,SUBMITTED,yes,"The mutant code will catch any error and return -1, while the original code has no error handling, so the error will propagate up the call stack, potentially leading to unexpected behavior or teration of the program",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
72,871,5,SUBMITTED,yes,"Aaccording to comment above snippet the milliseconds represented by the field may be negative. -1 is then interpreted by the caller as the actual value, so whatever exception occurs will not be meaningfully detected.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
86,872,6,SUBMITTED,no,1==1 and true are the same.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
82,872,2,SUBMITTED,no,1 == 1 evalutes to true.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
57,874,5,SUBMITTED,no,"The mutant returns (iUnitMillis * value) instead of (value * iUnitMillis).  Since multiplication is commutative, the mutant behaves the same.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
17,874,30,SUBMITTED,no,The mutant logic is equivalent,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
86,877,6,SUBMITTED,yes,"For value=1, the original code will not throw IllegalFieldValueException but the mutated code will.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
27,877,3,SUBMITTED,yes,"The mutant code is buggy because it modifies the value check to “value - 1”, which could allow a value that's actually too high to pass through without error, leading to potential issues in how the application functions.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
10,881,8,SUBMITTED,yes,"The reference variable 'iZone' is of type 'DateTimeZone', which is the parent class of many other classes. Through polymorphism, if 'iZone' is assigned an object of type 'FixedDateTimeZone' (i.e., 'iZone' is not null), the mutant code would return false when 'isFixed' is called. However, the original code would return true since 'iZone.isFixed()' would evaluate to true.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
49,881,10,SUBMITTED,yes,Mutant returns true if iZone is null and false otherwise. This is not directly related to whether Izone is fixed but rather whether the reference to the iZone object is null.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
23,885,4,SUBMITTED,yes,As it has to provide the copy of of the DateTime its output should be altered from actual DateTime. But mutant code adds addition millisec that produce difference.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
79,885,2,SUBMITTED,yes,"Here, in the original code, iInstant.getMillis() is rounded. But in the mutant version, iInstant.getMillis() + 1 is rounded which will always be 1 greater than the original case. Therefore, this is a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
47,885,6,SUBMITTED,yes,The buggy code will produce infinity exception,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
49,887,10,SUBMITTED,yes,"Mutant and Original are not equivalent as in the first one it checks if (‘a’ instance of ‘b’ and ‘c’ instanceof ‘d’) but in the mutant it checks if (typecasted to Element ‘c’ instance of ‘b’ and ‘a’ instance of ‘d’)  Also the datatype of source is org.jsoup.nodes.Node so the condition of source instanceof Element will never be true  Where ‘a’=source, ‘b’=org.jsoup.nodes.Element, ‘c’=dest.getParentNode() and d=’Element’",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
51,887,15,SUBMITTED,yes,"In the if clause, when the casting fails then there will be a runtime error. Instead of checking the casted being an instance of org.jsoup.nodes.Element it raises an error. If we are sure that the explicit casting is compatible this mutated version would not have been buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
90,890,5,SUBMITTED,yes,"The edited code introduces a bug by removing the check for num > 0 before accessing the evaluators list. This can lead to an IndexOutOfBoundsException if the list is empty, altering the program's behavior and potentially causing it to crash.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
81,890,15,SUBMITTED,yes,"If the value num is less than 0, the first code snippet will return null while the mutant one will return evaluators.get(num - 1), so the output will differ here.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
23,893,4,SUBMITTED,no,The mutant added just extra condition to return True or False. No behavioral or output change is occured.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
81,893,15,SUBMITTED,no,"Not buggy, both are equivalent",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
10,893,8,SUBMITTED,no,"In the original code, we directly use the condition to return a boolean value, while in the mutant, the condition is explicitly checked using an if statement. The mutant returns true if the condition evaluates to true and false otherwise.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
57,894,5,SUBMITTED,no,"The mutant inserts an extra line int x = 5 in a method.  x is not subsequently used anywhere.  If the mutant compiles, it always behaves the same.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
81,894,15,SUBMITTED,no,"Not buggy, declaring a local variable without using it does not affect the functionality of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
16,894,7,SUBMITTED,no,This addition of a local variable does not affect the behavior or output of the code because the variable x is never used and does not interfere with the assignment of the evaluator to the instance variable.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
81,899,15,SUBMITTED,yes,"The difference between both snippets is obvious. The first returns the indentamount( which might be an attribute of the class), but the other returns this value plus one",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
55,899,22,SUBMITTED,yes,"The mutant returns indentAmount+1 instead of indentAmount, which would result in incorrect behaviour during pretty printing of the data",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
30,906,10,SUBMITTED,no,"The only thing that changed is the indentation in the snippet, which will not affect the output or the behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
19,906,2,SUBMITTED,no,There is no change between the original and mutant apart from formatting which does not change the functionality,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
14,906,4,SUBMITTED,no,"Only space and indentation is changed, so codes are equivalent",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
55,906,22,SUBMITTED,no,"The mutant code returns the value of the valuesep variable, just like the original code. Thus, the mutant code is not buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
19,910,2,SUBMITTED,no,addition of this references the same variable in this instance and therefore makes no difference to the variable assignment,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
65,910,12,SUBMITTED,no,This is not a bug because this is not a local variable so this may be global and in that case 2 statements will do the same thing.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
23,911,4,SUBMITTED,no,The actual code is essentially return an Object[]. The mutant code additionally casted the return value to Object[] which is redundant but not chaning the method behavior or output. So its not a bug.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
21,911,6,SUBMITTED,no,"You are just recasting the elements to an array, where they are already in an array.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
38,913,1,SUBMITTED,no,There does not seem to be a problem in the function since in both cases it returns an instance of the comparator,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
12,913,3,SUBMITTED,no,it will return the same function since in same class,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
19,914,2,SUBMITTED,yes,Boolean logic is incorrect as it is missing truth value comparison of transformer,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
50,914,8,SUBMITTED,yes,"The mutant is only checking equality for the decorated property. This way, two instances will be considered equal even when their transformer property is different",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
75,914,21,SUBMITTED,yes,"The equality logic becomes partially wrong because the comparator's behavior isn't fully represented in the equals method since transformers doesn't have to be equal in the mutant version. For example, when using TransforgComparator instances as keys in a map or elements in a set, the modified equals method could lead to unexpected results such as considering distinct transformation behaviors as duplicates.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
102,914,10,SUBMITTED,yes,"The mutated code does not give the same deterministic output as the original code. The reason is that the original code checks for equality of both decorated and transformer fields, while the mutated code checks only the decorated field. This change alters the logic and can lead to different results when comparing instances, as it ignores the equality of the transformer field.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
67,916,15,SUBMITTED,no,there is no bug in this code. Just an additional parantheses.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
75,916,21,SUBMITTED,no,The placement of parentheses doesn't affect the outcome of the operation due to the associative property of subtraction.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
52,917,36,SUBMITTED,no,"there is no difference between the mutant code and the good one, that's why there will not be a bug",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
104,917,5,SUBMITTED,no,"I think not using ""this"" wont make it access parent class or function, so no change",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
42,917,15,SUBMITTED,no,it will have same result,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
32,921,20,SUBMITTED,no,"For the original case, the function returns an integer value based on what beforeFirst evaluates to.  In mutated case, the function also returns an integer value based  on what beforeFirst evaluates to. Adding parenthesis,adjusting the line spaces and changing the line of the curly braces does not affect the final output. Thus, this change is not a bug",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
70,921,9,SUBMITTED,no,Mutant code will give same output because it is using an equivalent way of writing an inline conditional statement.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
31,927,15,SUBMITTED,no,"That’s an obvious one. Only one line is deleted, and } was put above. The code’s output and behavior didn’t change.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
32,927,20,SUBMITTED,no,Changing the line of the curly braces from line 572 to line 571 does not affect the behaviour of the code or expected output.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
38,929,1,SUBMITTED,no,"there is an added brackets in the if statemnt in the mutant code , this does not raise an error . Hence it not a bug",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
80,929,2,SUBMITTED,no,This mutation just adds a redundant set of parentheses around the instance type checking logic. Adding it changes neither the program behavior nor the output. It runs exactly as it was supposed to do before.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
2,933,6,SUBMITTED,no,The parentheses will not affect the result.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
50,933,8,SUBMITTED,no,"Putting (i+1) in the mutant does not change the output, because the additional parentheses is redundant",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
94,937,30,SUBMITTED,no,The use of an extra pair of parentheses doesn't affect the code implentation.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
54,937,6,SUBMITTED,no,"The addition of an extra pair of parantheses doesnt change the behaviour or the outcome. Its not needed in this context as there's only one condition, so it doesnt need extra parantheses to perform grouping for the highest precedence",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
48,941,10,SUBMITTED,no,"In both the codes, the function returns 'of(IterableUtils.zippingIterable(iterable, other))'. Therefore the mutant is not buggy as far as the value of 'IterableUtils' is same in both the codes.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
63,941,5,SUBMITTED,no,"This mutant is purely reformatting the original code, therefore there shall be no change in code behavior. It is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
92,942,21,SUBMITTED,no,"The added parentheses do not change the outcome of the calculation because the precedence of addition and multiplication is already clear, and the added parentheses maintain the original sequence of operations. Both correctly implement the functionality of converting FileTime to NTFS time format.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
65,942,12,SUBMITTED,no,"This will not produce any bug because the * operation happens before +, so basically two are same.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
20,948,13,SUBMITTED,yes,Having the key word final before the char variable will not affect the code output as long as it's value is not changed after the first initialization,6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
47,948,6,SUBMITTED,no,"As per current code in the print comment function, adding the final keyword to make the variable c won't effect in any change as the variable is reading the data from comment which will always be passed by value and overriding the argument comment will still be read in variable c,",6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
97,948,2,SUBMITTED,no,"this is because the varible is not changed anywhere after the declaration. Final of variable ""c"" is redeclared every time the for loop iterates.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
12,948,3,SUBMITTED,no,"since c is not updated anywhere else, final is not required",6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
73,949,4,SUBMITTED,no,Removing a break statement after the default case in switch statements has no affect on the progammatic behaviour of the code.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
2,949,6,SUBMITTED,no,The switch statement does not need a break at end. It will naturally break.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
45,957,30,SUBMITTED,no,"In the original code, the getIndex() method is called on the current instance implicitly and the method checks if the index is equivalent to WHOLE_COLLECTION. Using “this” keyword does not affect the behavior of the code, it explicitly demonstrates the method is called on the current instance.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
59,957,2,SUBMITTED,no,this.getIndex() is same as getIndex() as only one getIndex() is present.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
63,960,5,SUBMITTED,no,"The mutant is not a bug because the method getAndIncrement() is still returning the variable ""last"" that has the value of ""value"" variable before it is incremented. The mutant has removed from the original code, the final keyword in the initialization statement of the ""last"" variable. This does not change the number returned by the given method as the ""last"" variable does not change its value before the return statement.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
104,960,5,SUBMITTED,no,last value not changed,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
72,960,5,SUBMITTED,no,last' is a local final variable. The mutant does not attempt to reassign the value. The behaviour is the same.,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
106,960,2,SUBMITTED,no,"the execute the same thing, the only difference is that the original masks the last variable a  final variable, so it can be changed, but it isn't changed so it doesn't do anything, but if that method is called again their might be a problem",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
66,961,14,SUBMITTED,no,both will give same answer and it is not a bug just declaring data type in variable which is already declared changes  nothing so mutant is not a bug,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
73,961,4,SUBMITTED,no,Both the original and mutated snippet return variable last of data type long.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
15,966,4,SUBMITTED,yes,"The mutant code always returns 1, while the original code returns a random number between the two arguments to the nextInt method",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
75,966,21,SUBMITTED,yes,It is buggy because mutant version always returns 1 instead of a random number between 0 and 2^32 - 1 (In our scenario),6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
93,973,7,SUBMITTED,no,Having the closing braces in a different line or the same line does not matter.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
5,973,18,SUBMITTED,no,"The mutant code provided is identical to the original code in terms of functionality. The only difference is the placement of the closing brace `}` for the readDeclaredStaticField method, which has been moved to the same line as the return statement. This is purely a stylistic change and does not affect the code's behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
63,975,5,SUBMITTED,no,"This mutant is just adding additional parentheses around the existing parentheses of the if-condition in the original code, therefore there shall be no change in code behavior. It is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
19,975,2,SUBMITTED,no,Additional brackets have no effect on the if statement evaluation,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
41,977,7,SUBMITTED,no,behavior and output is same as both checks if string is in uppercase and if it has a length of 2.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
33,977,4,SUBMITTED,no,"Not buggy, both behave similar and return same value for any given string. The explicit casting to string as done on the mutant snippet will not change the outputs",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
13,979,9,SUBMITTED,no,"There is no other variables with the name ""value"" inside the function, therefore using this. will not make a difference.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
70,979,9,SUBMITTED,no,"Both methods achieve the same functionality (regardless of ‘this’ keyword), which is to add operand to the instance variable value, and then return the original value of value before the addition.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
79,985,2,SUBMITTED,yes,"We know, when a variable is declared with the final keyword in Java, it means that the variable cannot be reassigned after its initial assignment. Therefore for the original code, the thread cannot be reassigned again. But in case of mutant version, it can be reassigned. Thus, the behavior is different here and the mutant is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,1,2,1,4,no,1/2/2001
70,985,9,SUBMITTED,no,"Since the initializeThread() method doesn't reassign the thread variable itself (neither in the case of a final declaration nor without it), but rather modifies the state of the Thread object referred to by thread, the behavior of the two code snippets remains the same.",6/26/2024 3:46,6/26/2024 3:46,0,1,2,1,4,no,1/2/2001
89,985,19,SUBMITTED,maybe,"It depends on the code. If the 'thread' is not supposed to change anywhere in the code then it must be initialized as final. The behaviour and output of the code is same, only the constraints in modifying the 'thread' is different.",6/26/2024 3:46,6/26/2024 3:46,0,1,2,1,4,no,1/2/2001
23,985,4,SUBMITTED,no,The final keyword in Java indicates that the variable cannot be reassigned after initialization. As I've inspect the codebase I don't see any redeclaration of thread variable that is passed in initializeThread method. Only some getter and setter methods are called. Therefore it's not buggy.,6/26/2024 3:46,6/26/2024 3:46,0,1,2,1,4,no,1/2/2001
28,988,5,SUBMITTED,no,There is no change in the mutant code,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
102,988,10,SUBMITTED,no,The mutated code gives the same deterministic output as the original code because they are identical. There is no change in logic or functionality between the original and mutated code.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
17,988,30,SUBMITTED,no,"Mutant expression is equivalent, only reformatted",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
8,990,6,SUBMITTED,no,"The change on mutant code is there is explicit cast to int, since the return type of method cardinality() is configured as int which have no side effect; Hence the mutant is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
14,990,4,SUBMITTED,no,typecasting int to int doesn't change output,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
35,991,6,SUBMITTED,no,Both of the codes execution renders the same result.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
26,991,8,SUBMITTED,no,Only the newline before the closing curly brace is removed.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
57,1001,5,SUBMITTED,no,"The mutant removes the ""final"" modifier from a method local variable.  There is no other assignment to the variable in the method.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
6,1001,11,SUBMITTED,no,Removing the final modifier from the variable declaration does not change the behavior of the method.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
7,1004,15,SUBMITTED,no,"The changes provides the same output. Hence, no bugs introduced",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
51,1004,15,SUBMITTED,yes,"Assug that value variable  could be of any type, the correct version will only work for cases the value is byte . but the mutated (the one with casting) will output a value that is of lower precision of lost value. Like if value is 1000,it will return -24.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
28,1004,5,SUBMITTED,yes,"s the mutant try to cast byte to a Byte object. This will not compile because Java does not allow casting between primitive types and their wrapper classes directly. You would need to use Byte.valueOf() or the constructor new Byte(byteValue) (Deprecated : It is rarely appropriate to use this constructor. The static factory valueOf(byte) is generally a better choice, as it is likely to yield significantly better space and time performance.) to create a Byte object from a byte primitive. that stated clearly in the Byte.java",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
31,1005,15,SUBMITTED,no,"value is a byte, and the function doubleValue() returns a double. In Java, the type conversion when returning a wide type is done implicitly, whereas returning a narrow type requires explicit type conversion. Here, the value is widened, and it is already done in the original code. (double) explicit conversion is redundant in this case, but it might be useful for clarity though. Therefore, the code’s output and behavior didn’t change.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
27,1005,3,SUBMITTED,no,"The mutated code is not buggy because the explicit casting of “value” to “double” in the mutated code does not introduce any functional change or error. The operation is redundant if “value” is already a double, meaning it doesn't affect the method result.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
98,1006,4,SUBMITTED,no,The left and right side are identical apart from white space which doesn't matter in Java.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
92,1006,21,SUBMITTED,no,"The difference between these two code snippets lies solely in formatting and indentation; logically, they are identical.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
54,1006,6,SUBMITTED,no,"changing the bracket position doesnt change the behaviour, as every is within their respective scope",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
22,1012,4,SUBMITTED,no,"Whitespace change, movement of closing brace to end of statement instead of on next line, and surrounding value with parantheses. Purely cosmetic and no functionality changes whatsoever.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
96,1012,2,SUBMITTED,no,The output is the same,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
77,1014,3,SUBMITTED,no,They are the same codes.,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
22,1014,4,SUBMITTED,no,Whitespace change and movement of closing brace to end of statement instead of on next line. Purely cosmetic and no functionality changes whatsoever.,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
33,1014,4,SUBMITTED,no,"This is because, just like the original correct snippet, it returns value variable, the space doesn't make any difference.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
92,1014,21,SUBMITTED,no,"The only difference is the extra whitespace at the end of the Mutant code. This whitespace does not affect the functionality of the code because the Java compiler ignores most whitespace. Therefore, there is no bug, just a coding style issue.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
91,1017,7,SUBMITTED,yes,The mutated code will return false in all situations.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
8,1017,6,SUBMITTED,yes,"The change in mutant code negates the logic that was present in the original code, resulting in a method that unconditionally returns “false”. This modification introduces unintended behavior and introduce bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
44,1018,45,SUBMITTED,yes,"The buggy code is indeed buggy. In the original (mutant) code, the getB method assigns different fractions to each element of the b array. Specifically, b[3] is assigned the result of fraction(-4).  In the buggy code, b[3] is assigned the result of fraction(-4, 3), which is a significant change from the original code. Additionally, b[2] is assigned twice in the buggy code, which means the first assignment b[2] = fraction(27, 32) is overwritten by the second assignment b[2] = fraction(27, 32). This is redundant and could be a potential bug if the first assignment was intended to be different. So, yes, the buggy code is really buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
61,1018,4,SUBMITTED,yes,Fraction requires two arguments,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
44,1019,45,SUBMITTED,yes,"The buggy code is indeed buggy. In the original (mutant) code, the hashCode method calculates the hash code based on the freqTable object. If freqTable is null, it contributes 0 to the hash code; otherwise, it contributes its own hash code.  In the buggy code, the hashCode method does not consider freqTable at all. Instead, it calculates the hash code as (prime * result) + prime, which is always equal to 2 * prime regardless of the values of the fields in the object. This is a significant change in behavior from the original code, making the buggy code buggy. The original method should calculate the hash code based on the freqTable object, not ignore it. So, yes, the buggy code is really buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
71,1019,4,SUBMITTED,no,the code having  a bug,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
78,1019,9,SUBMITTED,no,"""final"" keyword isn't affecting the behavior or return value of this code",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
91,1020,7,SUBMITTED,yes,"The original code throws an exception if the input value was infinite or not a number, but the mutant does not check for that when they throw the exceptions, which make the two codes have different behaviors.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
105,1020,0,SUBMITTED,yes,"The original method appropriately checks for NaN and infinite float values and only throws an exception when the writer is not lenient. One prominent behavioral change that is seen to be problematic is that the mutant incorrectly throws the exception for any float value when it is not in the lenient mode. If the writer is not forgiving, for example, the original code would permit a valid float number like 3.14 whereas the mutant code would incorrectly reject it.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
72,1021,5,SUBMITTED,yes,"An exception will now be thrown only if the field is not lenient, regardless of whether the value is a NaN or Infinity, which the function is supposed to detect.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
98,1021,4,SUBMITTED,yes,"The right throws an exception only on the condition that the JSON writer is not lenient without actually checking that it fails checks that a non-lenient writer would care about, like the left side.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
46,1021,2,SUBMITTED,yes,"The mutant code does not check if the 'value' is NaN or infinite. It directly prints the error. In the original code, the NaN and infinte conditions are checked, along with non-leniency of calendar format. Because of this, the mutant code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
75,1022,21,SUBMITTED,no,Java's conditional operator (? :) works the same way with or without these additional parentheses.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
3,1022,5,SUBMITTED,no,The extra parentheses in ((date != null)) makes no difference.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
82,1022,2,SUBMITTED,no,The mutant code only add extra parenthesis and remove white spaces and a line break,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
100,1025,3,SUBMITTED,no,Just parantheses and whitespace...,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
49,1025,10,SUBMITTED,no,"The only difference between the 2 codes is the formatting. In the mutant there is a parenthesis around the returned value and in the original there isn't.In the original, the closing brace (}) of the method is placed on a new line, whereas in the mutant, it is on the same line.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
7,1026,15,SUBMITTED,yes,"The main returns element from array, whereas the mutant returns just a number.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
100,1026,3,SUBMITTED,yes,Inequivalent values without g[.],6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
37,1026,6,SUBMITTED,yes,The correct code returns the value of g at k-K_ left shifted by 1 whereas the mutant code returns  k-K_. Thus the mutant is buggy.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
98,1029,4,SUBMITTED,no,"The right side is the semantically equivalent to the left, it just adds extra parentheses and additionally unnecessarily casts a long value to a long.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
2,1029,6,SUBMITTED,no,Adding parentheses does not change the order of operations.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
11,1035,2,SUBMITTED,no,The diamond operator is used to improve code readability and will not affect the output. The diamond operator ensures the type of instance created.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
51,1035,15,SUBMITTED,no,the actual behavior and functionality of the LinkedHashSet object will be the same in both scenarios. The main difference lies in how the code is written and how it is interpreted by the Java compiler. Its a question of type checking befire compiling.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
74,1040,2,SUBMITTED,no,Functionally both are same.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
50,1040,8,SUBMITTED,yes,"The original code checks if referringProperties is not null and is not empty, so the final result is influenced by empty check. While the mutant only check for null twice.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
37,1040,6,SUBMITTED,yes,If the value of _referringProperties is not equal to null but the Iterator is empty then the correct code returns false but the mutant code returns true. So this is a bug.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
48,1044,10,SUBMITTED,yes,"In the orginal code, the function returns 'generator.isValidReferencePropertyName(name, parser)' while the function in the mutant code returns 'generator.isValidReferencePropertyName(name, true)'. Hence the code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
12,1044,3,SUBMITTED,yes,"Since the mutated version does not check for structure of object, but directly gives true as parameter",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
57,1045,5,SUBMITTED,no,The mutant only changes the formatting.  The actual code is identical.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
21,1045,6,SUBMITTED,no,"It is the same expression, but the ""}"" is on the same line in the mutant code instead of being on a seperate line in the main code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
30,1047,10,SUBMITTED,no,"The only thing that changed is the indentation in the snippet, which will not affect the output or the behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
66,1047,14,SUBMITTED,no,both code are identical,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
72,1049,5,SUBMITTED,no,The only mutation is to the indentation.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
58,1049,9,SUBMITTED,no,The only difference between the mutant and original code is formatting. This would not cause any behavioral issues or inconsistent output with the original.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
17,1051,30,SUBMITTED,no,The two logics are identical,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
64,1051,8,SUBMITTED,no,Both the mutants and the original code are same except for white spaces,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
46,1051,2,SUBMITTED,no,The placing of flower braces on a new line does not make any difference to the running of the code. Hence the mutant code is not buggy.,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
15,1051,4,SUBMITTED,no,The difference in indentation and bracketing will not affect the results in java. In python the indentaion difference will cause an error,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
53,1056,13,SUBMITTED,no,Removal of extra whitespace without altering any other aspect of the code.,6/26/2024 3:46,6/26/2024 3:46,0,1,2,0,3,no,1/2/2000
43,1056,4,SUBMITTED,maybe,"The mutated code is working correctly, and the difference lies in the return value, which may not be considered a bug.",6/26/2024 3:46,6/26/2024 3:46,0,1,2,0,3,no,1/2/2000
45,1056,30,SUBMITTED,no,"In both cases, the only difference is how the snippets are formatted, specifically where the close braces are put. The way braces are aligned in Java does not affect the functionality; therefore, it is not a buggy mutant. However, following the same formatting style is always a good practice.",6/26/2024 3:46,6/26/2024 3:46,0,1,2,0,3,no,1/2/2000
46,1057,2,SUBMITTED,no,Using the disable feature twice in the same code on the same parameter list will only disable the feature ONCE. Hence the mutant code will function exactly as the original code. The mutant code is not buggy.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
48,1057,10,SUBMITTED,no,Both the original and mutant codes return '_this()' and disable 'features'. Therefore the mutant is not buggy.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
56,1057,4,SUBMITTED,yes,"mapper.disable function is called twice, redundancy.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
61,1058,4,SUBMITTED,no,"protected <T extends JsonNode> T _this()), there would be no practical difference between return (T) _this() and return _this() if the generic type parameter T is appropriately constrained.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
90,1058,5,SUBMITTED,no,"The edited code (B)_this(); simply adds an unnecessary cast to the _this() method call. The _this() method already returns the correct type, so the cast does not change the behavior of the method or the class functionality in any meaningful way.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
66,1063,14,SUBMITTED,yes,"n the mutated code, the method will always return null,while in correct code on left handside it will decide hasAnyGetterAnnotation((AnnotatedMethod) ann then will return value according to it true or null",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
86,1063,6,SUBMITTED,yes,Won’t return true if the condition is true.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
93,1063,7,SUBMITTED,yes,Mutated version always returns null unlike correct version.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
56,1065,4,SUBMITTED,no,"Only closing curly bracket is moved one line above, during compilation it wont matter as individual tokens will be created.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
34,1065,3,SUBMITTED,no,It just removes extra space.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
24,1067,3,SUBMITTED,no,"RHS code adds an unnecessary cast to the return value, which doesn't change the behavior",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
94,1067,30,SUBMITTED,no,There is no functional difference between the two return statements.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
87,1068,9,SUBMITTED,no,Because it is just a repeated lines of codes,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
21,1068,6,SUBMITTED,no,"It is the same expression, but the ""}"" is on the same line in the mutant code instead of being on a seperate line in the main code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
18,1069,3,SUBMITTED,yes,Because most of the left code is commented out.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
24,1069,3,SUBMITTED,no,"difference is the type annotation in the first line, which does not affect the code's functionality",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
89,1069,19,SUBMITTED,no,"The behavior and output of the two code snippets would be the same. Only the memory and number of resize operations would be affected. The hashmap in the original code has an initial capacity of 8 and the hashmap in the mutant has 16. As the number of elements in a hashmap increase, resize operation takes place to adjust the size of the hashmap for new elements. In the right snippet, if actual number of elements are less than 16 then memory will be wasted. If the count is greater than 16, then there will be more resize operations. Hence, only the performance of the code is affected and not its output.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
54,1078,6,SUBMITTED,no,"Since there's no local variable named ""_className"" inside the costructor, both codes achieve the same outcome (""this"" in this case is optional)",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
10,1078,8,SUBMITTED,no,"The mutant code uses 'this._classname' to refer to the field '_classname'. Thus, the mutant performs the same task as the original code and is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
55,1079,22,SUBMITTED,no,"The mutant casts the result of ClassUtil.rawClass() to Class<?>, but this is unnecessary because the method already returns a Class<?> object. However, this unnecessary cast does not change the behavior or functionality of the code, and so the mutant is not bugg",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
68,1079,18,SUBMITTED,no,it is because the function is already nullable so we can return null and it will be already handled,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
43,1081,4,SUBMITTED,yes,"The mutated code always returns 1, which is a bug according to the original and correct version of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
59,1081,2,SUBMITTED,yes,Mutant will always return 0. Correct code can return other values.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
10,1081,8,SUBMITTED,yes,"The mutant always returns 0, but the original code does not. '_forward' is a reference variable of type 'SettableBeanProperty', which is a parent class of many subclasses. These subclasses override the 'getCreatorIndex' function to return an integer, but many do not (they use the function defined in the parent class). Hence, the original code would use runtime polymorphism to execute the function, whereas the mutant always returns 0.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
97,1082,2,SUBMITTED,no,casting an int as an int does not change anything. we know _forward.getCreatorIndex() is in. int because in the correct code it must return an int.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
64,1082,8,SUBMITTED,no,The mutant function is explicitly typecasting the function which will not affect the function behavior or output.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
76,1082,12,SUBMITTED,no,"The mutant version typecasts the output and returns it, but it doesnot affect the program's output .",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
6,1088,11,SUBMITTED,no,"the code is the same, it is identical",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
21,1088,6,SUBMITTED,no,"It is the same expression, but the ""}"" is on the same line in the mutant code instead of being on a seperate line in the main code.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
62,1088,6,SUBMITTED,no,"The mutant restores the intended behavior by using this as the argument, fixing the issue in the buggy code.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
11,1101,2,SUBMITTED,no,Add extra parenthesis doesn’t affect the output of the boolean expression here.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
68,1101,18,SUBMITTED,no,double brackets are not required so not a bug,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
17,1107,30,SUBMITTED,no,The extra parenthesis are redundant and do not affect the logic,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
87,1107,9,SUBMITTED,no,because both code will behave and have the same output,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
88,1108,5,SUBMITTED,no,The added int type cast is on the return value of a function that has return int type. so no behaviour is changed.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
25,1108,2,SUBMITTED,no,"In the original code, the method is supposed to return an integer value that is going to be allocated to a variable of type integer. The mutated code shows that the method's returned value is type casted to become integer, so it ends up resulting in the same thing",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
89,1108,19,SUBMITTED,no,"The mutant code is just perforg type to int. It is not needed since the GJChronology method getimumDaysInFirstWeek() returns an int type. However, including it in the code does not change the behavior and output.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
18,1110,3,SUBMITTED,yes,DateTimeConstants.MILLIS_PER_DAY is not always 0 therefore code returns a different result for mutant code than the original code.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
29,1110,2,SUBMITTED,yes,"Without inspecting the precise meaning of the magic number constants in ""EthiopicChronlogy"" class that implements Ethiopian calendar system I can only assume that the mutated code contains bug because its missing the ""+ 112L * DateTimeConstants.MILLIS_PER_DAY"" in the numerator.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
65,1111,12,SUBMITTED,no,The codes are same.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
44,1111,45,SUBMITTED,yes,"The buggy code is indeed buggy. In the original (mutant) code, the eraTextToValue method returns the integer value of the era object if it is not null. This is done by calling era.intValue().  In the buggy code, the eraTextToValue method always returns 0 if era is not null, regardless of the actual value of era. This is a significant change in behavior from the original code, making the buggy code buggy. The original method should return the integer value of era, not always 0. So, yes, the buggy code is really buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
89,1111,19,SUBMITTED,no,The code is entirely same except for a difference in indentation.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
32,1111,20,SUBMITTED,no,"Changing the line of the curly braces just improves readability, it doesn't change the output or the behaviour of the code",6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
34,1113,3,SUBMITTED,yes,It changes return era.intValue(); to return era; attempting to return an Integer object instead of an int primitive.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
4,1113,1,SUBMITTED,yes,"The first function returns era.intValue(), while the second function returns era only. era might be a class and you have to use the function eraValue to get the needed values as you can't return a class",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
88,1115,5,SUBMITTED,no,"The mutated version just changed some whitespace characters, which doesn't change the code behaviour.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
27,1115,3,SUBMITTED,no,"The mutant code is not buggy because it is structurally and functionally identical to the original code, with no changes that affect its operation or behavior. The mutation only involves formatting, which does not impact the code logic or output.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
6,1115,11,SUBMITTED,no,there is no difference in the code,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
12,1116,3,SUBMITTED,no,improves upon original code by type casting to int beforehand,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
80,1116,2,SUBMITTED,no,This mutant version adds an additional type cast to integer before calling the “Seconds.seconds()” and return the corresponding value. It results in neither behavior change nor a different output.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
18,1117,3,SUBMITTED,no,"Codes are the same just the indentation is different, which does not important in this case since code is in Java.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
49,1117,10,SUBMITTED,no,"In the mutant, the closing brace (}) of the method is placed on a new line, whereas in the correct/original, it is on the same line. This will not affect the output of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
52,1117,36,SUBMITTED,no,The code is not buggy one as there is no change in the output or change in the behavior of the code but the difference is only a styling which will not effect or cause any bugs,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
4,1120,1,SUBMITTED,no,"The only change is the casting that changes the datatype into long. The function returns long so either way the value returned is long, so it doesn't matter writing long before the returned value",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
32,1120,20,SUBMITTED,no,"In the original case, the function return type is long, which implies that iUnitMillis should be of long type. But in the mutant case, the function return type is still long, with an added syntax of casting iUnitMillis to long. This should not cause a bug in the code",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
86,1131,6,SUBMITTED,no,Both codes are the same.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
53,1131,13,SUBMITTED,no,Removal of extra whitespace without altering any other aspect of the code.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
63,1136,5,SUBMITTED,no,"This mutant is purely reformatting the original code, therefore there shall be no change in code behavior. It is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
26,1136,8,SUBMITTED,no,Only the newline before closing curly brace is deleted.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
86,1137,6,SUBMITTED,yes,"For any time value e.g. 10ms, original code will return 10*iScale but mutated code will return only iScale. It also does not serve the purpose of the class since “Scales a DurationField such that it's unit millis becomes larger in  * magnitude.” and without multiplication, the milis won’t scale.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
87,1137,9,SUBMITTED,yes,The mutant does not perform any operation on the “iscalar” entity/ variable.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
91,1141,7,SUBMITTED,no,"The conditions for the if statement is identical. Hence it does not change the output of the code but is redundant; however, the mutant is not buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
58,1141,9,SUBMITTED,no,"The mutant code has the condition if(((other == null) && (other == null))) which is redundant because it checks other == null twice. This doesn't alter the logical flow since the redundancy doesn't affect the outcome of the condition. The comparison after the null check remains the same, so the method's behavior when other is not null is unchanged.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
62,1142,6,SUBMITTED,no,The mutant doesn't affect the behavior of the isGreaterThan() method.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
20,1142,13,SUBMITTED,no,Having paranesthesia around the return statement in the mutant code not going to change its value.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
42,1142,15,SUBMITTED,no,it returns same thing,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
41,1147,7,SUBMITTED,no,"there was an unnecessary type casting to the right, however, both methods will produce same output.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
39,1147,3,SUBMITTED,no,"typecasting is okay, isFixed will return bool anyway",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
25,1147,2,SUBMITTED,no,"The expected return value is boolean in the original code, so if it gets type casted to boolean as well in the mutated code, the resultant value will still be the same",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
90,1148,5,SUBMITTED,no,"The edited code is identical in function to the original code; the only difference is in the formatting, specifically the indentation of the return statement. Since the execution path, logic, and outcomes remain unchanged by this edit, it does not introduce any behavioral difference or fault in the program's functionality.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
25,1148,2,SUBMITTED,no,The mutated code is still within the scope of the method same as the original code,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
7,1148,15,SUBMITTED,no,Both are same. Slight difference in formatting.,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
14,1148,4,SUBMITTED,no,"Only spacing and indentation change, does not affect original code",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
49,1150,10,SUBMITTED,no,In the original code the return type is an instance of the Weeks class as specified in the function declaration  ( public Weeks toStandardWeeks() ). In the mutant the same value being returned is type casted to be an instance of the Weeks class. This will not affect the output as it is already of the same class it is being type casted to in the original snippet.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
33,1150,4,SUBMITTED,no,"The explicit casting to Weeks, as done in the mutant snippet will not change the output.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
29,1150,2,SUBMITTED,no,Casting in the mutated code is redundant and it does not lead to data loss because the object being casted is of the same type as the type its being casted to.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
99,1151,6,SUBMITTED,no,The only difference between the two snippets is the formatting and the placement of closing braces and whitespace.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
74,1151,2,SUBMITTED,no,Return value will be the same,6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
68,1151,18,SUBMITTED,no,just a change of brackets so it does not make it buggy,6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
95,1151,68,SUBMITTED,yes,Wrong loop,6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
16,1153,7,SUBMITTED,no,Same code with different spacing.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
42,1153,15,SUBMITTED,no,it is the same code,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
71,1153,4,SUBMITTED,no,The line of code was not a bug inside just we tried to change the elments and it works,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
99,1155,6,SUBMITTED,no,The only difference between the two snippets is the formatting and the placement of closing braces and whitespace.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
53,1155,13,SUBMITTED,no,Removal of extra whitespace without altering any other aspect of the code.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
73,1159,4,SUBMITTED,yes,"The original method will return a SimpleTimeZone for unusual offset. However in the mutated code , an offset starting with null would return GMT timezone .",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
16,1159,7,SUBMITTED,yes,"The change in the mutated version introduces a bug because it incorrectly handles the case where the ID starts with ""null"". This could lead to unexpected behavior when dealing with time zone IDs that start with ""null"".",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
81,1160,15,SUBMITTED,yes,"In case application deals with multiple calendar systems (for example, Gregorian and Julian calendars), the first snippet would allow for more precise control over the interval's calculation and interpretation according to the specified chronology.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
74,1160,2,SUBMITTED,yes,Changed code is calling the child class while first one is calling a super class,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
80,1162,2,SUBMITTED,no,"The modified version of the code snippet additionally performs a type casting to the “DateTimeFieldType” before returning the DAY_OF_MONTH_TYPE constant. Albeit containing a redundant modification, the mutant version perfectly outputs the same as the original version with no behavior change issues.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
60,1162,8,SUBMITTED,no,"DAY_OF_MONTH_TYPE is already of type DateTimeFieldType, so its a redundant cast but will not change anything.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
103,1174,6,SUBMITTED,no,The mutant is not a bug because in java whitespace does not matter as long as the brackets {} in the if and else statements have the same code and therefore should return the same thing with not bugs.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
47,1174,6,SUBMITTED,no,This indendation change will not produce any change in program outcome,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
13,1174,9,SUBMITTED,no,"The only difference is in the indentation and line breaks, no difference in functionality.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
79,1175,2,SUBMITTED,no,"Here, as trackPosition is a member of Parser class, this.trackPosition is similar to using trackPosition itself. Therefore, the mutant version is not buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
40,1175,4,SUBMITTED,no,Mutated code and the original code should produce the same output. The addition of this in the mutated code ( this.trackPosition ) is not necessary in this context because trackPosition refers to the instance variable of the class. Both versions are valid and equivalent.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
60,1176,8,SUBMITTED,no,Whitespace change :D,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
5,1176,18,SUBMITTED,no,"The mutant code provided is identical to the original code in terms of functionality. The only difference is the placement of the closing brace `}` for the isTrackPosition method, which has been moved to the same line as the return statement. This is purely a stylistic change and does not affect the code's behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
103,1177,6,SUBMITTED,no,"The mutant is not buggy assuming that trackPosition is already a boolean since you want you need to return a boolean value, within the mutant it is casting trackPosition to a boolean which would still return true or false.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
91,1177,7,SUBMITTED,no,"The original function already is returning a boolean type. The mutant changes the return value of trackPosition to a boolean even though it is already a boolean. This mutant does not change behavior of the code, but is redundant.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
88,1177,5,SUBMITTED,no,"trackPosition has boolean type, so type casting this variable to boolean will not make any changes.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
73,1177,4,SUBMITTED,no,Variable 'trackPosition'  is casted to its original type of boolean. This has no effect on the code and does not change any behaviours.,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
79,1178,2,SUBMITTED,no,"There is no difference between the original and mutant version of the code other than the formatting. So, the code behavior will be the same for the mutant version here.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
106,1178,2,SUBMITTED,no,"the mutant and the original are the same thing, but only have different in coding formatting, which either is acceptable, for example, the mutant has the closing brace at the end of the return statement as apposed to in a new line",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
71,1178,4,SUBMITTED,no,we only brought the brackets to the line of the previous code which remains the same things,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
4,1181,1,SUBMITTED,yes,The parameter passed in the function of the first code is d.getPubSysKey(). While it's Null in the second code.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
47,1181,6,SUBMITTED,yes,In first case a varrying key is added but in the changed case null is always passed,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
13,1185,9,SUBMITTED,no,The indentation and line breaks are just different which does not change the implementation.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
41,1185,7,SUBMITTED,no,the codes are exactly same on both ends and it returns parser.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
42,1192,15,SUBMITTED,yes,if owner is null it will call newRequest other than Jsoup.newSession(),6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
41,1192,7,SUBMITTED,yes,owner.connection().newRequest() is called directly without checking if owner is null to the left and reverse is the case for the left hand side.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
7,1194,15,SUBMITTED,no,The function on both main and mutant returns same Connection class instance.,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
3,1194,5,SUBMITTED,no,It will just typecast the Connection object to Connection object. The modified code is redundant but doesnot cause any difference in behaviour,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
1,1194,2,SUBMITTED,no,"The mutant only added the casting to return type, which is already of the type Connection",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
59,1197,2,SUBMITTED,yes,Left code can return a non-null code.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
3,1197,5,SUBMITTED,yes,"This straight returns null every time, causing the method to behave differently.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
25,1207,2,SUBMITTED,no,"They all evaluate to true if both beforeFirst and removed are false, and they evaluate to false otherwise. Therefore, both the original and mutant code gives the same result",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
22,1207,4,SUBMITTED,no,"Here we have a condition of the form A AND A which just evaluates to A, i.e. the condition does not change and the code behaves identically. The branches are equivalent because of DeMorgan's laws ((NOT A and NOT B) is NOT(A or B)).",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
15,1207,4,SUBMITTED,no,Both !beforeFirst && !removed and !(beforeFirst || removed) are essentially the same condition as both conditions will only be true if both beforeFirst andremoved are False,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
47,1213,6,SUBMITTED,yes,In changed scenario the first value will keep being added for the complete iteration which is completely different behaviour from the initial scenario,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
32,1213,20,SUBMITTED,yes,"In the original case, for each iteration it adds the ith element of composite array to the keys set. But in the mutated case,  for each iteration it adds the 0th element of the composite array to the keys set. Doing this alters the expected way the code supposed to function and thus causing a bug",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
82,1215,2,SUBMITTED,yes,"Since there is a check if object == this in line 121, if object != this, the method will always return false.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
10,1215,8,SUBMITTED,yes,"Here when we reach the last return statement we have established that 'object' is not equal to 'this'. Hence the extra statement in the mutant code always evaluates to 'false'. When object is equal to this both will return true, but when object is not equal to this mutant code will always return false unlike the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
88,1218,5,SUBMITTED,yes,"When a collection is list of iterators, then in this case the FluentIterator.contains will not work same in original and mutated code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
97,1218,2,SUBMITTED,yes,This is a bug because object is an instance of the FluentIterable class. This leads to a false statement all the time,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
81,1226,15,SUBMITTED,yes,"Definitely, the return value will differ after the change. Before the modification, whenever the getKey() value is null, the value of the getValue() will be returned. In contrast, after the modification, if the getKey() is null, the return value would be (256 ^  getValue()). Also, if both are null, the first code snippet will return 0 while the second code snippet will return 256. So, the modification changes the behavior of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
88,1226,5,SUBMITTED,yes,"Hashcode of the pairs that have null keys is changed in mutant. An example of change of code behaviour could be following: A code that reports a pair is (null, null) in case that hashcode is zero.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
71,1227,4,SUBMITTED,yes,it should not return null and otherwise 0.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
65,1227,12,SUBMITTED,no,As 1st one is doing 0 to null and onother one is 255 to null the implementation is different but I don't think it will produce bug.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
60,1227,8,SUBMITTED,yes,255 will lead to different results than 0 under the XOR operation.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
57,1234,5,SUBMITTED,yes,"The mutant replaces this == object with this == null && x, which is always false.  The mutant behaves differently when this == object.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
18,1234,3,SUBMITTED,yes,mutant version doesn't return a value if this is not a null.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
37,1234,6,SUBMITTED,yes,this and object may point to the same non-null object and thus have the same content. The correct code will return true in such case. The mutant code will skip over the condition of returning true despite having the same content as (this == null) will not satisfy. Thus they will have different fundamental behaviour.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
39,1234,3,SUBMITTED,yes,"This function will never go into if block and return true since ""this"" cannot be null because it refers to the current object instance, so this part of the if condition will be always false",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
4,1238,1,SUBMITTED,yes,passing false differs from passing true to the function,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
92,1238,21,SUBMITTED,yes,,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
85,1242,2,SUBMITTED,yes,,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
98,1242,4,SUBMITTED,yes,"The right side does not have the same behavior becuase iArgs points directly at args instead of a clone of args, meaning if args is modified elsewhere in the program, iargs will change or if iargs is modified in the program, the variable passed into args will also change.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
50,1242,8,SUBMITTED,yes,"The original code makes a shallow copy of the args array, while the mutant directly reference the args array.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
99,1245,6,SUBMITTED,no,The mutated code add an extra logic condition which is logically equivalent to the original code. hence there is no changes in program's behaviour.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
47,1245,6,SUBMITTED,yes,In case of nextObjectSet being True and setNextObject retring True the changed logic will return False whlist the init logic will return True. The program behaviour will change,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
70,1245,9,SUBMITTED,no,"The hasNext() method will return the value of (nextObjectSet || setNextObject()) in both the cases. The condition !(!nextObjectSet && !setNextObject()) always evaluates equal to former expression hence && of both results in same value. Hence, both codes give the same output.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
77,1251,3,SUBMITTED,no,"Both are functionally equivalent in terms of their logic and the outcome they produce, they use different approach.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
57,1251,5,SUBMITTED,no,"The mutant replaces 0xFF with 255, which is the same value.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
38,1253,1,SUBMITTED,yes,"The function Assemble array is essentially making a byte array data which has in the intial five positions (position 0 to 4 ) the values corresponding the bytes in ""nameCRC32"", and then the byte data in UnicodeName. In the mutant code the array copy results in only one compenent being copied. This is a bug",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
78,1253,9,SUBMITTED,yes,both give different results because they copy different numbers of elements,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
36,1254,4,SUBMITTED,yes,The version of the unicode array is assigned to the first byte in the normal code whereas the third byte in the mutant. In the mutant while copying the array the version will be overwritten and hence may cause errors.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
17,1254,30,SUBMITTED,yes,The second System.arraycopy expression will result in a different output because of the change,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
74,1254,2,SUBMITTED,yes,"This is definitely gonna change the code behaviour since the value was assigned to the first element earlier, which is later assigned to the 3rd element",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
53,1256,13,SUBMITTED,yes,"Integer._VALUE is -2³¹, not  1.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
99,1256,6,SUBMITTED,yes,"The mutated version introduces a bug because it changes the acceptable range of seconds. The mutated code has range [1, Integer.MAX_VALUE] where as the original code has range of [Integer.MIN_VLAUE, Integer.MAX_VALUE] which is different.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
47,1257,6,SUBMITTED,no,There was a chance of behaviour change if one of the logics had a changing variable. As in both conditions there is a common variable second and the /max values are constants this will not run into not defined kind of errors,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
93,1257,7,SUBMITTED,no,"Since the <= does not throw an exception &&, & operator exhibit similar behaviour in this case as the second input to & operator is guarenteed not to throw an exception.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
11,1257,2,SUBMITTED,yes,The && is a comparison operator while the & is a bitwise operator that manipulates the bits,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
35,1259,6,SUBMITTED,no,The execution will remain same as the mutated code's '||' won't have any effect on the code execution,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
10,1259,8,SUBMITTED,no,"Upon reaching the last return statement, it is established that 'Double.isNaN(rd)' evaluates to false, as the condition has already been checked. Therefore, the result depends solely on the 'evaluateCompare' function (as the mutant does evaluateCompare() || false for all inputs), and the same value would be returned in both the mutant and the original code in all cases.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
60,1259,8,SUBMITTED,no,"The only line changed is the last, and for it to reach that line without returning before, rd is guaranteed to be false, therefore its going to have no impact on the result.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
103,1259,6,SUBMITTED,no,"The mutant is not a bug because by adding  || (Double.isNaN(rd) to return (evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1)). It is always going to be false, because if it were true then it would return false. Since it is false then we know that evaluateCompare is either true or false. True or False is still True and False or False is still False so the mutant is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
11,1265,2,SUBMITTED,yes,the function will return always 1,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
71,1265,4,SUBMITTED,yes,The code having a buggy because of not returning value.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
24,1268,3,SUBMITTED,yes,"Bug introduces a logical OR (||) condition which means that if either index is greater than or equal to WHOLE_COLLECTION or parent.getIndex() is not equal to WHOLE_COLLECTION, the method will return true",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
14,1268,4,SUBMITTED,yes,"`index>= WHOLE_COLLECTION` will always return true, so it will give true for all values of index",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
8,1268,6,SUBMITTED,yes,"The mutant code has been changed to check either index is greater than or equal to WHOLE_COLLECTION, or parent.getIndex() is not equal to WHOLE_COLLECTION. Therefore, this syntactic change in condition will indeed change the output and behavior of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
81,1269,15,SUBMITTED,no,"Not buggy, the difference would be in the performance not on the outcome.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
7,1269,15,SUBMITTED,no,Both implementations provide a HashSet list whereas the one with larger size can give better performance avoiding frequent resizing.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
28,1273,5,SUBMITTED,no,as if  perfix == null  it will return perfix (which is already null) in both cases (the original code and the mutant),6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
4,1273,1,SUBMITTED,no,"If the prefix == NULL, it doesn't matter if we return the prefix of NULL because they are equal",6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
90,1273,5,SUBMITTED,yes,"The change from returning null when prefix is null to returning the prefix itself (which is null in this scenario) alters the method's return value in such a situation but does not change the behavior in a meaningful way. The method's intent is to fetch a namespace URI corresponding to a prefix. When there is no prefix, there should indeed be no namespace URI, and both returning null directly or returning prefix (which is null) result in the same outcome: no namespace URI. Therefore, the edited code does not introduce a fault in terms of the functionality expected from this method, as the outcome of calling the method remains unchanged.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
39,1273,3,SUBMITTED,no,"If the value of prefix is null, so it will not make a difference if we hardcoded the value null or variable name itself.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,1,4,no,0/3/1
77,1274,3,SUBMITTED,yes,"In this case null is different from empty string, they don't go together.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
26,1274,8,SUBMITTED,yes,"prefix may be null, null == null, but null != """".",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
37,1276,6,SUBMITTED,yes,The correct code produces false when obj is null but this is not null. But the mutated code doesn't produce false in that case at least with the code visible.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
29,1276,2,SUBMITTED,yes,"Mutated code overwrites originals code if guard that checks if passed object ""obj"" is null. Therefore if null is passed to the mutated function,  ""obj.getClass()"" would yield a runtime exception (NullPointerException).",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
36,1279,4,SUBMITTED,yes,The baseclass should return 1 as the task count. If the method is overriden it can return higher values but the mutant returns 2 instead of 1.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
72,1279,5,SUBMITTED,yes,"Although the given snippet returns a constant and derived classes can override this method to return other constants, the mutant would be providing an incorrect value to a caller to this implementation.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
62,1290,6,SUBMITTED,yes,The mutant introduces a bug by ignoring the operand and always adding 1 to the value.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
72,1290,5,SUBMITTED,yes,"The function is meant to add an operand's value from the value of the instance, the mutant adds 1 to the value of the instance.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
37,1293,6,SUBMITTED,yes,In the correct code the current value of last is returned before it is incremented. But the mutated code always returns 1.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
88,1293,5,SUBMITTED,yes,"Mutated version always returns 1, which is clearly a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
99,1294,6,SUBMITTED,yes,"The original code returns a variable value, whereas the buggy one just returns 1. hence, unless value==1, this code is not valid.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
40,1294,4,SUBMITTED,yes,"The mutated code will produce different output as of the original code. The method returns the actual value stored in the value variable. However, the mutated code returns the value 1 unconditionally, disregarding the actual value stored in the object, which leads to different output than the intended output.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
18,1294,3,SUBMITTED,yes,"The original function returns the the 'value' of type short as a float. Since a short does't have to be 1 or rounded to 1, it can convert other values. mutated version returns 1 in any case, therefore it is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
25,1299,2,SUBMITTED,yes,"In the original code, Double.MAX_VALUE contains the maximum possible positive number while the mutant code contains the range between 0 and 2. Since the method's purpose is to generates a random double within 0 - Double.MAX_VALUE, this code is mutant",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
16,1299,7,SUBMITTED,yes,It restricts range to specific number.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
73,1301,4,SUBMITTED,yes,"In the mutated code the method returns value incremented by 1. However, in the original code the method is expected to return value after adding the operand.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
80,1301,2,SUBMITTED,yes,"The original code takes the parameter ""operand"" and adds it to the variable “value”. But the mutant version of the function “addAndGet” always keeps adding 1 to the “value” variable, despite being passed with different operands. For example, in case where “value”=10 and “operand”=5, the original code snippet returns 15, while the changed code returns 11.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
29,1305,2,SUBMITTED,yes,"Mutated code returns null whilst the original code returns reference to the object on which the method ""clear()"" is being invoked.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
34,1305,3,SUBMITTED,yes,"The modified code introduces a bug because it changes the return value of the method from 'this' to 'null'. This change means that when the method is called, it will always return null instead of the FluentBitSet instance and potentially causing NullPointerExceptions if the returned value is used further.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
16,1306,7,SUBMITTED,no,"The use of this keyword in Java is optional and is used to refer to the current instance of the class. In the context of the getValue() method, both versions behave the same way.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
29,1306,2,SUBMITTED,no,"There is no difference between returning ""this.value"" in contrast to just ""value"". Note that if, for some reason, function ""getValue()"" had a parameter with the same name as the member variable ""value"", usage of keyword ""this"" would be required to distinguish between these two values.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
43,1306,4,SUBMITTED,yes,"The original code returns the value of ""value"", but the mutated code always returns null!",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
52,1307,36,SUBMITTED,yes,"Regardless the operand, he incorrectly added +1 instead of operand which changes both the output and the behavior of the method.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
11,1307,2,SUBMITTED,yes,The mutant code returns the original value + 1 while the original code returns the value + the operand.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
9,1309,9,SUBMITTED,no,Not bug,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
34,1309,3,SUBMITTED,no,"The modified code doesn't introduce a bug because it simply changes the variable being updated ('total' instead of 'value'), maintaining the original logic intact. Thus, it should function correctly and perform the intended task of adding the operand to the total while returning the original value.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
103,1311,6,SUBMITTED,yes,"The mutant is buggy because last is now set to a reference type and then won’t return the same thing on the left since last is set to a primitive type it won’t change and keeps the original data, while the value is added based off the operand double value, while on the right it is referencing to this so it will change and not keep the old value.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
97,1311,2,SUBMITTED,yes,"the correct one the value of ""value"" before the method was called is stored in ""last"". In the mutant's case the instance of the class is stored in ""last"".",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
47,1318,6,SUBMITTED,yes,"The changed line of code inserts another functionality to check whether the provided class was of enum type, if not, then the changed code will return true even if the getEnumIgnoreCase would've returned false. So, this will result in changed behaviour in the program",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
22,1318,4,SUBMITTED,yes,"When !enumClass.isEnum() is true, then the chained call to getFirstEnumIgnoreCase will return null. null != null evaluates to false originally, but now evaluates to true when OR'd with  !enumClass.isEnum() (this is what started the scenario in the first place).",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
33,1319,4,SUBMITTED,yes,"It is buggy because value instance of the class is incremented by last instead of operand, hence subsequent operations will return wrong values.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
17,1319,30,SUBMITTED,yes,Mutation adds value to itself instead of the new operand,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
33,1320,4,SUBMITTED,yes,"Since the value of the operand can vary, adding 1 instead of the operand to the value instance of the class will cause the code to return wrong values.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
103,1320,6,SUBMITTED,yes,"The mutant is buggy because you are adding 1 instead of the operand which is not always going to be 1, this behavior is different. Though, they are both returning the same value.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
43,1321,4,SUBMITTED,yes,The mutated code always returns zero regardless of the value of 'value'!,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
88,1321,5,SUBMITTED,yes,"Mutated version always returns 1, which is clearly a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
13,1322,9,SUBMITTED,no,"The check is unnecessary but will not result in a bug or difference in code since the if statement above it will check if ""str"" is null and return null, therefore if str is null, the function returns before getting to the mutated code. The str==null in the mutated part will never be true, and anything or-ed with false is always itself.",6/26/2024 3:46,6/26/2024 3:46,0,0,5,0,5,no,0/5/0
59,1322,2,SUBMITTED,no,"If str==null, then the second if condition will never be reached",6/26/2024 3:46,6/26/2024 3:46,0,0,5,0,5,no,0/5/0
62,1322,6,SUBMITTED,no,"The mutant adds another null check (str == null) before the combined isEmpty or deepEmpty check. However, since the first check (str == null) already handles the null case, the additional check in the mutant is redundant. It won't affect the final outcome as long as the first if statement works correctly (which might be broken in the buggy code).",6/26/2024 3:46,6/26/2024 3:46,0,0,5,0,5,no,0/5/0
89,1322,19,SUBMITTED,no,"The condition on line 154 is checking if 'str' is null. The return statement on line 155 will end the execution of the function whenever 'str' is null. The program will only run line 157 whenever 'str' is false. Hence, the result of the if statement will depend on the str.isEmpty() || deepEmpty(set) (same as in the left statement). In simple words, p OR false is p in logic where p can be any statement.",6/26/2024 3:46,6/26/2024 3:46,0,0,5,0,5,no,0/5/0
100,1322,3,SUBMITTED,no,Functionally equivalent since the null-check is already false if the function did not already return.,6/26/2024 3:46,6/26/2024 3:46,0,0,5,0,5,no,0/5/0
22,1327,4,SUBMITTED,no,"We have an equality of the form A == B. ORing that equality with B == A will not change the result (false OR false = false, true OR true = true, equality is commutative)",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
25,1327,2,SUBMITTED,no,"The original code compares the values of the two attributes whereas the mutant code does the same but with the order reversed with an or operator, therefore the behavior will be there same",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
92,1327,21,SUBMITTED,no,"In the mutated code version, the conditional statement is expanded to check if `param.getParameterName()` is equal to `pName`, or if `pName` is equal to `param.getParameterName()`. Logically, this is redundant, but it does not affect the functionality of the code.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
80,1328,2,SUBMITTED,yes,"The mutant version adds a new conditional check which involves an undeclared variable named “parameter” inside the concerned function. It is also not any class member variable, which could make its usage valid. Hence it is indeed a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
67,1328,15,SUBMITTED,yes,"Parameter is actually an int (private int parameter = -1;) but getParameterName() function returns String. And when I compare string and int, it will return false every time. And since there is && (and) operator which prevent us entering the if statement.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
80,1330,2,SUBMITTED,yes,"The mutant version uses a variable named “digits” instead of “digit” used in the older original version. Clearly this new variable is not introduced anywhere else in the code file. Hence, it is a clear bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
51,1330,15,SUBMITTED,yes,"there is no existing digits to be multifpled with f, in the mutant, so this will output an error.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
76,1331,12,SUBMITTED,yes,"The ImageFormat Has no option for ""Image"" it only supports files like PNG,JPG etc.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
30,1331,10,SUBMITTED,yes,"According to ImageFormats.java, the valid constants in the ImageFormats enum are UNKNOWN, BMP, DCX, GIF, ICNS, ICO, JBIG2, JPEG, PAM, PSD, PBM, PGM, PNM, PPM, PCX, PNG, RGBE, TGA, TIFF, WBMP, WEBP, XBM, and XPM. This change will cause a compilation error.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
51,1340,15,SUBMITTED,yes,"the two have different behaviors and will produce different results. The correct one performs a single update attempt, while the second function attempts multiple updates recursively until the comparison fails.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
74,1340,2,SUBMITTED,yes,Returning two different functions in the code snippet,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
89,1341,19,SUBMITTED,yes,"The function in the mutant is the recursive function. Although the answer would be same as the original code because there is an AND operator between both the functions and attemptNeuronUpdate is being called with the same parameters. However, the function will never stop and will result in infinite recursion.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
35,1341,6,SUBMITTED,yes,Original code had only one return condition compareAndSetFeatures while in the mutated code compareSetFeatures is getting an argument feature and the return is also depending on the neuronUpdate,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
14,1343,4,SUBMITTED,yes,value of 2*dimension and 2^dimension is not equal. That is multiplication and xor with 2 is not equal,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
13,1343,9,SUBMITTED,yes,"The mutant code is buggy since the mutant code xors with 2 while the original function multiplies the dimension by 2, which will return 2 different numbers.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
26,1346,8,SUBMITTED,yes,"If the array is non-null, but the length is zero, and allowEmpty is true, verifyValues() returns true, however, length != 0 would return false, and the if statement would not be executed while it should be.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
48,1346,10,SUBMITTED,yes,"In the orginal code, the if statement only checks for 'MathArrays.verifyValues(values, begin, length, true)' while in the mutant code the if statement checks for both '(length != 0)' and '(MathArrays.verifyValues(values, begin, length, true))'. Therefore the mutant code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
39,1349,3,SUBMITTED,no,the extra condition(j < nVars) is replicated since the second for loop will take care of it,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
27,1349,3,SUBMITTED,no,"The mutant code is not buggy because the mutation adds a redundant condition that does not affect the functionality or outcome of the code. The extra check “j < nVars” is unnecessary since it is always true within the loop's bounds, thus not introducing a functional bug or altering the code logic.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
27,1354,3,SUBMITTED,yes,"The mutant code is buggy because it uses a bitwise AND operator “(&)” instead of a logical AND operator “(&&)”. This could cause both conditions to always be evaluated, changing the intended logic and possibly allowing NaN or infinite values through if “isLenient()” is false, against the original code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
21,1354,6,SUBMITTED,no,"The ""&"" evaluates both expressions, then bitwise and their values. The ""&&"" evaluates the first expression, if it was false, it doesn't evaluate the second expression, if it was true it evaluates the second expression and returns true if both were true and false otherwise.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
67,1354,15,SUBMITTED,no,"Since every value is Boolean it wont create a bug, but it gets rid of advantage of lazy evaluation thanks to &&. But it isn't a buggy code.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
81,1355,15,SUBMITTED,yes,The difference between the two snippets is that the original one returns the current instance of the class while the modified version returns null. The second case would be problematic if this exception was part of a function chain because it would throw a NullPointerException.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
94,1355,30,SUBMITTED,yes,The use of 'return null' as a return statement leads to runtime errors in subsequent method chaining,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
17,1360,30,SUBMITTED,yes,INCLUDE_ALL will always be an instance of TokenFilter and not equivalent to null,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
52,1360,36,SUBMITTED,yes,"The change will effect and is buggy because it compares INCLUDE_ALL to NULL which is not the intended logic, as it alters the behavior of toString method",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
57,1361,5,SUBMITTED,yes,"Mutant returns """" instead of ""TokenFilter.INCLUDE_ALL"".  The mutant behaves differently whenever this line is executed.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
43,1361,4,SUBMITTED,yes,"As an object is always equal to itself, the mutated code always returns ""TokenFilter.INCLUDE_ALL"", and the ""super.toString()"" line is unreachable.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
24,1362,3,SUBMITTED,no,"Both codes return string of the object. this.toString() is used instead of super.toString(), resulting in same output",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
55,1362,22,SUBMITTED,yes,"The mutant will keep on recursively calling its own toString method, instead of calling the toString method of its superclass as used in the original code",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
98,1362,4,SUBMITTED,yes,"Returning a new object doensn't fulfill the implied specification of the method name which is to acess the current value of a field. The left side always returns the value of the field while the right always returns a new Object, meaning the right would only be valid if the field could only store a new Object.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
30,1363,10,SUBMITTED,yes,"The value of delegateCopyMethods will always be false. As a result, the class will always handle copy methods locally and will not delegate them to the underlying JsonGenerator.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
101,1363,6,SUBMITTED,yes,"Yes. The mutant case does not change the value of attribute delegateCopyMethods to the parameter value delegateCopyMethods. Therefore, the two versions are not equivalent and this can impact later functionality that is based on the updated value of this attribute",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
105,1368,0,SUBMITTED,no,The mutant introduces a redundant condition that does not change the functionality of the code. The behavior remains the same as the original code since both conditions check for contentRef == null.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
32,1368,20,SUBMITTED,no,"In the original case the conditional statement checks if contentRef is null. But in the mutated case, the conditional statement double checks if the contentRef is null. Though redundant, it doesn't affect the output of the code and thus is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
38,1372,1,SUBMITTED,yes,"the function asText is designed to return defaultValue in cases where null values is returned in the str , but in the code it returns emplty inverted commas ("""") in place of the defaultValue. This means the program is buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
96,1372,2,SUBMITTED,yes,It disgards the input defaultValue!,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
5,1372,18,SUBMITTED,yes,"In the original code, if str is null, the method will return the defaultValue provided as an argument. This allows the caller to specify what value they want in case str is null.  In the mutant code, if str is null, the method will always return an empty string, regardless of what defaultValue was provided. This means that the defaultValue argument is ignored in cases where str is null.  So, if the defaultValue is an empty string, the original code and the mutant code will give the same result. But if the defaultValue is anything other than an empty string, the two pieces of code will give different results when str is null.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
80,1372,2,SUBMITTED,yes,"Here, the mutant version replaces the “defaultValue” with “”, an empty string meaning that whatever the received defaultValue string is, won’t be returned when the str to be compared is null. Hence, a bug found.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
13,1385,9,SUBMITTED,yes,"The config object that is being accessed is not even declared as parameter inside the class, the null check is for prop, so if config is null the code will still execute. This is buggy code.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
12,1385,3,SUBMITTED,yes,Changed prop to config,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
41,1385,7,SUBMITTED,no,both ends has same behavior and output as prop and config reference same object.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
104,1387,5,SUBMITTED,yes,The added part changes condition to (_typeHandler != null) && (_valueHandler == null),6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
89,1387,19,SUBMITTED,yes,Made a boolean table of the variables and the result was opposite.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
73,1388,4,SUBMITTED,yes,The mutant method returns True only if both type and value handlers are not null. However original code is expected to return True even if only one of them not null.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
35,1388,6,SUBMITTED,yes,"In the original code, either of the condition can be true to render a result but, in the mutated code both conditions should have to be same to render a result.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
23,1388,4,SUBMITTED,yes,"According to the doc if there are either Type or Value Handler, it should return true. But the mutant code contain && that denotes the presence of both of the handlers which doesn't comply with the condition of the actual code. So, its a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
75,1390,21,SUBMITTED,yes,"If clz is null, the mutant method returns true, which is not a standard type-checking behavior where null would not be considered a valid type for comparison and should logically result in false because null cannot define a type relationship. This changes the behaviour.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
39,1390,3,SUBMITTED,yes,"if null == clz, the function will return true indicating that this clz is a subtype of the _class, however it is not.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
76,1390,12,SUBMITTED,yes,Comparision with null value,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
72,1395,5,SUBMITTED,yes,additionalSerializers' may be a non-empty list of providers for serializers. Passing null forces default serialization which is not the same behavior.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
101,1395,6,SUBMITTED,yes,"Yes. The mutant case creates a new SerializerFactoryConfig object that has a different value for object attribute _additionalSerializers, therefore, these two versions are not equivalent",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
103,1399,6,SUBMITTED,no,"The mutant is not buggy because both elements() and iterator() that allows you to retrieve elements one by one, elements create an enumeration and iterator creates an iteration.",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
101,1399,6,SUBMITTED,no,"No. The mutant case calls on iterator() instead of elements(), however, when looking at the function definitions, we see that iterator() returns elements(). Therefore, both versions are equivalent",6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
68,1399,18,SUBMITTED,no,in our case n is json node so iterator is fine to use with it as we can iterate over its immediate childrens,6/26/2024 3:46,6/26/2024 3:46,0,0,3,0,3,no,0/3/0
28,1401,5,SUBMITTED,yes,because the code return new PropertyMetadata without any  _mergeInfo (null),6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
98,1401,4,SUBMITTED,yes,"The left side returns a new PropertyMetaData that is initialized with according to the mergeInfo field whereas the right side always constructs the new object with the null value, making it a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
91,1409,7,SUBMITTED,yes,"In the mutant the argument this is not a parser, even though it needs to be. Hence the code is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
14,1409,4,SUBMITTED,yes,It sends wrong reference as argument to the function,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
23,1412,4,SUBMITTED,no,if ((toIgnore == null) && (toIgnore == null)) this addition of the same condition doesn't necessrily change the method behavior.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
66,1412,14,SUBMITTED,no,toIgnore == null is checked twice within the same code which is unnecessary it doesnot change any output,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
21,1414,6,SUBMITTED,yes,"In the main code, you are only checking if the Strings are null. In the mutated version, you are checking if they are equal or they are null.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
78,1414,9,SUBMITTED,yes,"mutant will bahve differently because it was added that function will also return false if toIgnore ==toInclude condition is fulfilled, regardless of the other condition",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
28,1414,5,SUBMITTED,yes,as if the (toIgnore == toInclude) this makes an conflict between both and that makes both return true or both return false that makes the function always outputs true in the original code but always returns false in the mutant code,6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
104,1417,5,SUBMITTED,no,"The hashmap will not return a value less than 0 for its size, so adding it onto an ""and"" comparison does nothing",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
65,1417,12,SUBMITTED,no,"This is not a buggy code as we can see that in the function, we are returning false if the '_annotation' is Null and if not we are returning ""_annotations.containsKey(cls)"". In the mutant we can see that the part of the Null repeats so if that data structure is empty then it will return false before hand and when it is not Null then obviously that size of the structure is not equal to Null.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
83,1417,9,SUBMITTED,yes,the buggy implementation returns false when _annotations is not null. Which negates the purpose of having the condition. It should return false when it is null,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
28,1419,5,SUBMITTED,maybe,as the extra and MapperFeature.USE_ANNOTATIONS is set to True and I cannot find anyware the MapperFeature.USE_ANNOTATIONS changed so it will be buggy if changed if not changed it will behave the same as X and true = X,6/26/2024 3:46,6/26/2024 3:46,0,2,0,0,2,maybe,2/0/0
106,1419,2,SUBMITTED,maybe,the mutated version could have a bug because the mutated version has an extra requirement to go into the if statement that could potentially not allow the if statement go throw while the original would,6/26/2024 3:46,6/26/2024 3:46,0,2,0,0,2,maybe,2/0/0
102,1433,10,SUBMITTED,yes,"The mutated code does not give the same deterministic output as the original code. The reason is that the original code requires both equality (via super.equals(object)) and a specific type (instance of MiddlePinNeedle) for the method to return true. The mutated code only requires equality, ignoring the type check, which can lead to different results when the object is not an instance of MiddlePinNeedle.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
52,1433,36,SUBMITTED,no,"Addition of else at the last if statement is the difference between the two snippets, addition of else at the last if statement will not make the snippet buggy due to the return statement which terates the method execution at each if statement.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
62,1433,6,SUBMITTED,yes,"The original buggy code unintentionally removes the return true; statement after the check for object instanceof MiddlePinNeedle. This means even if the object is the correct type (MiddlePinNeedle), the method now returns false. The mutant restores the missing return true; statement, fixing the logical error and making the equals method function as intended.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
99,1438,6,SUBMITTED,yes,"The mutated version introduces a bug because it changes the conditions under which the exception is thrown. Original Code: Always throws an exception if range is not precise. Mutated Code: Only throws an exception if range is not equal to this.iRangeField and is not precise, allowing for a case where range can be imprecise without throwing an exception.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
55,1438,22,SUBMITTED,yes,"In the mutant, consider the case when range==this.iRangeField.The first condition of the AND becomes false and therefore the entire AND becomes false. This bypasses the precision validation, deviating in behaviour from the original code. Thus, the mutant is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
4,1440,1,SUBMITTED,yes,"There is a new condition added which is (range==unit), which might affect the results",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
77,1440,3,SUBMITTED,yes,It adds extra checking which is not our intention in this case.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
78,1441,9,SUBMITTED,yes,In the mutant additional condition is added. So if that is not fulfilled it might not execute as expected,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
42,1441,15,SUBMITTED,yes,"range and unit are hard to be equal to each other, it won’t run the exception unless they are equal and range not precise",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
20,1446,13,SUBMITTED,yes,"In the original code if year  is less than 0, negative value of year is returned otherwise year is returned.   In the mutant code if year is less than 2000 then negative value of year is returned otherwise year is returned. The conflict between the two is when year is less 2000 and greater than 0, then different values will be returned.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
91,1446,7,SUBMITTED,yes,"The mutant does not display the same behavior as the original code. The original code will output the absolute value of the year, but the mutant will return negative values for years that are smaller 2000 and larger than 0.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
58,1453,9,SUBMITTED,no,"The mutant code has the condition if ((value <= iSkip) && (value <= iSkip))  which is redundant because it checks (value <= iSkip) twice. This doesn't alter the logical flow since the redundancy doesn't affect the outcome of the condition. The logic after the if statement remains the same, so the method's behavior remains unchanged.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
3,1453,5,SUBMITTED,no,"When (value <= iSkip) == true. true && true = true. When (value <= iSkip) == false, false && false == false. This doesn't change the outcome.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
52,1457,36,SUBMITTED,yes,"The added condition thisMillis == 1 changes the logic of the method, if thisMillis is 1 and otherMillis is any value other than 1, the method would incorrectly indicate that the two values are equal. The change will be considered as a bug as it changes the behavior of the comparison method",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
100,1457,3,SUBMITTED,yes,otherMillis need not be 1 if thisMillis is 1.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
4,1458,1,SUBMITTED,yes,"The returned value changes for sure, as we multiply DateTimeConstants.MILLIS_PER_DAY with 352 in the first code, while we multiply it with 2 in the second code",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
19,1458,2,SUBMITTED,yes,Added value is different,6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
31,1458,15,SUBMITTED,yes,"352L and 2 are not the same, therefore resulting long value would get affected. Hence, the mutant code changes the code’s output and behavior.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
3,1458,5,SUBMITTED,yes,"Except for when DateTimeConstants.MILLIS_PER_DAY is 0, the value returned by the function will be a different number every time.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,4,4,yes,0/0/4
96,1460,2,SUBMITTED,yes,The output is not the same,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
49,1460,10,SUBMITTED,yes,"In the original code there was a multiplication sign between “352L” and “DateTimeConstants.MILLIS_PER_DAY)”. In the mutant this multiplication sign becomes a plus sign. This will change the output, thus it is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
5,1461,18,SUBMITTED,yes,"The mutant code has changed the behavior of the getMaximumValue method. In the original code, the method returns iDivisor - 1, which is one less than the divisor.  In the mutant code, it returns iDivisor - 2, which is two less than the divisor.  This change in behavior could lead to bugs, as the method no longer returns the correct maximum value according to the original specification (one less than the divisor).",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
2,1461,6,SUBMITTED,yes,The maximum remainder should be -1 rather than -2.,6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
45,1462,30,SUBMITTED,yes,"It is a buggy mutant. In a division operation, the maximum remainder is always “divisor - 1.” In the mutant code, a miscalculated value is returned because of the iDivisor - 3.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
40,1462,4,SUBMITTED,yes,"Mutated code will produce a bug. The original subtracts 1 from iDivisor, but the mutated code subtracts 3 from iDivisor, which results in different output.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
96,1467,2,SUBMITTED,no,this.getMillis() can deal with the mutant case,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
67,1467,15,SUBMITTED,no,I looked at each function definitions and i found that they actually return exactly the same long expression.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
2,1469,6,SUBMITTED,yes,"The phrase ""Field"" will be missing.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
21,1469,6,SUBMITTED,no,"The only difference is the message raised in the error, instead of ""Field' field_name'..."", the message is ""'..."".",6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
46,1469,2,SUBMITTED,no,Only an extra 'Field' word is printed in the original code as compared to the mutant code. The mutant code is not buggy.,6/26/2024 3:46,6/26/2024 3:46,0,0,2,1,3,no,0/2/1
69,1474,4,SUBMITTED,yes,The first argument in getInstance is always null in mutant code while it is a timezone instance in the original code,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
24,1474,3,SUBMITTED,yes,RHS code is buggy due to the incorrect handling of the null case in the instance creation step,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
19,1474,2,SUBMITTED,no,Passing null to the function when base case is null has the same functionality,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
87,1480,9,SUBMITTED,no,"because the mutant code( original code) return type is long and will thus always return a long type to it’s call, the Buggy code isn’t buggy in this sense since the behavior of this code will not change with respect to the function call",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
46,1480,2,SUBMITTED,no,"In the original code, 'value' is of integer data type. There is no need of typecasting it to long integer type before storing it in a long integer variable, because that happens implicitly (int<long in size). Hence, both codes give the same result. The mutant code is not buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
87,1483,9,SUBMITTED,yes,"because of the introduction of the monthDay.Month_of_Year, this change the entire behavour of  the code",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
6,1483,11,SUBMITTED,yes,"he mutated version ""b"" modifies the condition, which could lead to accessing elements outside the valid range of the array.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,2,2,yes,0/0/2
8,1484,6,SUBMITTED,yes,"In the Mutant code, there is an additional condition in if statement i.e. (other != Weeks.TWO) with “AND” logic to (other == null), this introduces a contradiction conditions. The mutant code is checks both the other is not equal to Weeks.TWO and that is equal to null. Hence when the other is null, for this case the output and behavior of code changes which might be buggy.",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
46,1484,2,SUBMITTED,maybe,"In the original code, if 'other' is null, the return statement is executed. In the mutant code, 'other' should be null and also, Week.TWO should not be null for the return statement to be executed. As we do not know the value of Weeks.TWO, we cannot be certain if the if condition in the mutant code will be satisfied. Hence the mutant code maybe buggy.",6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
69,1484,4,SUBMITTED,yes,Mutant will return getValue() > 0 for all cases where other is not equal to week.TWO,6/26/2024 3:46,6/26/2024 3:46,0,1,0,2,3,yes,1/0/2
58,1487,9,SUBMITTED,no,Since we are assug constant days in the week which are 7 (as per the comments) this code change is not buggy.,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
102,1487,10,SUBMITTED,no,The mutated code gives the same deterministic output as the original code because both expressions multiply getValue() by the same value (7).,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
61,1487,4,SUBMITTED,no,DAYS_PER_WEEK is set to 7 in the main code itself,6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
54,1487,6,SUBMITTED,no,"The ""Days_per_week modifier"" returns a 7-day week, so writing down 7 manually won't change the outcome nor the behaviour",6/26/2024 3:46,6/26/2024 3:46,0,0,4,0,4,no,0/4/0
63,1489,5,SUBMITTED,no,"The variable ""key"" will never be null due to the validation in place during the creation of an Attribute class object. Therefore, the first condition in the if-clause of the ""getWholeDeclaration"" method will always be false. The logical OR for a false statement and another statement is always equal to the second statement. The second statement is the same in both the mutant and the original code. Hence, the mutant is not a bug.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
50,1489,8,SUBMITTED,no,"If key is null, both the original and mutant will evaluate to true. If key is not null, they will be equivalent in checking for inequality.",6/26/2024 3:46,6/26/2024 3:46,0,0,2,0,2,no,0/2/0
79,1491,2,SUBMITTED,maybe,"In Java, empty and null strings are not the same. So, to confidently detere if the mutant is buggy, we have to know how empty and null strings are handled in the Document class constructor.",6/26/2024 3:46,6/26/2024 3:46,0,1,2,0,3,no,1/2/2000
42,1491,15,SUBMITTED,no,both of them outputs empty document,6/26/2024 3:46,6/26/2024 3:46,0,1,2,0,3,no,1/2/2000
87,1491,9,SUBMITTED,no,The Mutant is just another but longer way of writing the mutated code,6/26/2024 3:46,6/26/2024 3:46,0,1,2,0,3,no,1/2/2000
65,1493,12,SUBMITTED,yes,In the buggy version when we are giving it and empty string it is a buggy code then it will be buggy also if we give it Null also.,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
96,1493,2,SUBMITTED,yes,change charsetName to file might lead to incorrect parsing,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
50,1493,8,SUBMITTED,no,The parse method allows null to be passed for the charsetName beause of the @Nullable annotation,6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
79,1496,2,SUBMITTED,yes,"Here in the mutant version of the code, the validation is removed to check if maxPaddingWidth >= -1. In the original code, if maxPaddingWidth < -1, the validation will fail which will throw an exception. But in case of the mutant version, no such exception will be thrown. So, there is a difference between the two and hence the mutant is buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
54,1496,6,SUBMITTED,yes,"Removing the ""validate"" line changes the functionality of the code. The function clearly states that assigning ""maxPaddingWidth"" local variable to the member variable ""maxPaddingWidth"" is solely on the basis that the value is "">=-1"". By having the validation function, if the value is ""<-1"", an exception will be thrown, thus not perforg assignment. Therefore, the mutant is buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
44,1496,45,SUBMITTED,yes,"The buggy code is indeed buggy. In the original (mutant) code, the maxPaddingWidth method does not perform any validation on maxPaddingWidth before assigning it to this.maxPaddingWidth.  In the buggy code, the maxPaddingWidth method validates that maxPaddingWidth is greater than -1. This is a significant change in behavior from the original code, making the buggy code buggy. The original method should not perform any validation on maxPaddingWidth, but the buggy code does. So, yes, the buggy code is really buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,0,3,3,yes,0/0/3
6,1497,11,SUBMITTED,yes,"The change in the validation condition from -1 to -100 in the mutated version ""b"" relaxes the constraint on the valid input values for maxPaddingWidth",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
8,1497,6,SUBMITTED,no,"The code “Validate.isTrue(maxPaddingWidth >= -100)” does not have any impact on the following flow of code. Either it be -1 or -100, there is no output changes or the behavior changes. Also if the ‘maxPaddingWidth’ is corresponds to the padding of node in which -1 is set to be unlimited (looked through the code base repository) in that case ‘-1’ or ‘-100’ servers the same logic.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
44,1497,45,SUBMITTED,yes,"The buggy code is indeed buggy. In the original (mutant) code, the maxPaddingWidth method validates that maxPaddingWidth is greater than or equal to -100.  In the buggy code, the maxPaddingWidth method validates that maxPaddingWidth is greater than -1. This is a significant change in behavior from the original code, making the buggy code buggy. The original method should allow maxPaddingWidth to be as low as -100, not just greater than -1. So, yes, the buggy code is really buggy",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
6,1498,11,SUBMITTED,yes,"In the mutated code ""b,"" the validation condition is changed to maxPaddingWidth >= -10",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
8,1498,6,SUBMITTED,no,"The code “Validate.isTrue(maxPaddingWidth >= -10)” does not have any impact on the following flow of code. Either it be -1 or -10, there is no output changes or the behavior changes. Also if the ‘maxPaddingWidth’ is corresponds to the padding of node in which -1 is set to be unlimited (looked through the code base repository – file: StringUtil.java; line: 129) in that case ‘-1’ or ‘-10’ servers the same logic.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
44,1498,45,SUBMITTED,yes,"The buggy code is indeed buggy. In the original (mutant) code, the maxPaddingWidth method validates that maxPaddingWidth is greater than or equal to -10.  In the buggy code, the maxPaddingWidth method validates that maxPaddingWidth is greater than -1. This is a significant change in behavior from the original code, making the buggy code buggy. The original method should allow maxPaddingWidth to be as low as -10, not just greater than -1. So, yes, the buggy code is really buggy.",6/26/2024 3:46,6/26/2024 3:46,0,0,1,2,3,yes,0/1/2
